{"version":3,"file":"site.js","sources":["webpack://webgpu-test/./Controller/Controller.ts","webpack://webgpu-test/./Logic/BoxCollider.ts","webpack://webgpu-test/./Logic/Dialog.ts","webpack://webgpu-test/./Logic/Logic.ts","webpack://webgpu-test/./Rendering/ImageLoader.ts","webpack://webgpu-test/./Rendering/Mesh.ts","webpack://webgpu-test/./Rendering/Renderer.ts","webpack://webgpu-test/./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js","webpack://webgpu-test/webpack/runtime/define_property_getters","webpack://webgpu-test/webpack/runtime/has_own_property","webpack://webgpu-test/webpack/runtime/make_namespace_object","webpack://webgpu-test/webpack/runtime/rspack_version","webpack://webgpu-test/webpack/runtime/rspack_unique_id","webpack://webgpu-test/./main.ts"],"sourcesContent":["import { Logic } from \"../Logic/Logic\";\n\nexport class Controller {\n    private logic: Logic;\n    private htmlCanvas: HTMLCanvasElement;\n\n    public constructor(logic: Logic, htmlCanvas: HTMLCanvasElement) {\n        this.logic = logic;\n        this.htmlCanvas = htmlCanvas;\n\n        this.htmlCanvas.onresize = () => this.logic.setWindowResized();\n\n        this.htmlCanvas.onclick = () => this.htmlCanvas.requestPointerLock();\n\n        this.htmlCanvas.onmousemove = this.onMouseMove;\n        document.onwheel = this.onMouseWheel;\n\n        document.onkeydown = this.onKeyPressed;\n        document.onkeyup = this.onKeyReleased;\n    }\n\n\n    private onMouseMove = (e: MouseEvent) => {\n        if (document.pointerLockElement !== this.htmlCanvas)\n            return;\n\n        this.logic.rotateCamera(e.movementX, e.movementY);\n    }\n\n    private onMouseWheel = (e: WheelEvent) => {\n        this.logic.zoomCamera(e.deltaY);\n    }\n\n\n    private ctrlPressed: boolean;\n    private altPressed: boolean;\n\n    private onKeyPressed = (e: KeyboardEvent) => { this.onKeyTriggered(true, e); }\n\n    private onKeyReleased = (e: KeyboardEvent) => { this.onKeyTriggered(false, e); }\n\n    private onKeyTriggered(pressed: boolean, e: KeyboardEvent) {\n        switch (e.code) {\n            case \"KeyW\": this.logic.moveForward = pressed; e.preventDefault(); break;\n            case \"KeyS\": this.logic.moveBackward = pressed; e.preventDefault(); break;\n            case \"KeyA\": this.logic.moveLeft = pressed; e.preventDefault(); break;\n            case \"KeyD\": this.logic.moveRight = pressed; e.preventDefault(); break;\n            case \"Space\": this.logic.moveUp = pressed; e.preventDefault(); break;\n            case \"ShiftLeft\": this.logic.moveDown = pressed; e.preventDefault(); break;\n            case \"ControlLeft\": this.logic.moveFast = (this.ctrlPressed = pressed) || this.altPressed; e.preventDefault(); break;\n            case \"AltLeft\": this.logic.moveFast = (this.altPressed = pressed) || this.ctrlPressed; e.preventDefault(); break;\n        }\n    }\n}\n","import { Vec3, vec3 } from \"wgpu-matrix\";\n\nexport class BoxCollider {\n    public ax: number;\n    public bx: number;\n\n    public ay: number;\n    public by: number;\n\n    public az: number;\n    public bz: number;\n\n    public constructor(ax: number, bx: number, ay: number, by: number, az: number, bz: number) {\n        this.ax = ax;\n        this.bx = bx;\n        this.ay = ay;\n        this.by = by;\n        this.az = az;\n        this.bz = bz;\n    }\n\n    public static create(position: Vec3, radius: number) {\n        return new BoxCollider(position[0] - radius, position[0] + radius, position[1] - radius, position[1] + radius, position[2] - radius, position[2] + radius);\n    }\n\n\n    private isAx: boolean;\n    private isBx: boolean;\n\n    private isAy: boolean;\n    private isBy: boolean;\n\n    private isAz: boolean;\n    private isBz: boolean;\n\n    /** aabb testing */\n    public hasCollision(otherCollider: BoxCollider): boolean {\n        // x-coordinate   ax <---> bx\n        this.isAx = this.ax < otherCollider.ax && otherCollider.ax < this.bx;\n        this.isBx = this.ax < otherCollider.bx && otherCollider.bx < this.bx;\n        const noneX = otherCollider.ax <= this.ax && this.bx <= otherCollider.bx;\n        if (!this.isAx && !this.isBx && !noneX)\n            return false;\n\n        // y-coordinate   ay <---> by\n        this.isAy = this.ay < otherCollider.ay && otherCollider.ay < this.by;\n        this.isBy = this.ay < otherCollider.by && otherCollider.by < this.by;\n        const noneY = otherCollider.ay <= this.ay && this.by <= otherCollider.by;\n        if (!this.isAy && !this.isBy && !noneY)\n            return false;\n\n        // z-coordinate   az <---> bz\n        this.isAz = this.az < otherCollider.az && otherCollider.az < this.bz;\n        this.isBz = this.az < otherCollider.bz && otherCollider.bz < this.bz;\n        const noneZ = otherCollider.az <= this.az && this.bz <= otherCollider.bz;\n        if (!this.isAz && !this.isBz && !noneZ)\n            return false;\n\n        return true;\n    }\n\n\n    public handleCollision(otherCollider: BoxCollider): Vec3 {\n        function MinDistance(isA: boolean, isB: boolean, a: number, b: number, otherA: number, otherB: number): number {\n            if (isA && !isB)\n                return b - otherA;\n            else if (!isA && isB)\n                return a - otherB;\n            else {\n                const da = otherB - a;\n                const db = b - otherA;\n                if (da < db)\n                    return -da;\n                else\n                    return db;\n            }\n        }\n\n        const dx = MinDistance(this.isAx, this.isBx, this.ax, this.bx, otherCollider.ax, otherCollider.bx);\n        const dy = MinDistance(this.isAy, this.isBy, this.ay, this.by, otherCollider.ay, otherCollider.by);\n        const dz = MinDistance(this.isAz, this.isBz, this.az, this.bz, otherCollider.az, otherCollider.bz);\n\n        if (Math.abs(dx) < Math.abs(dy))\n            if (Math.abs(dx) < Math.abs(dz))\n                return vec3.create(dx, 0.0, 0.0);\n            else\n                return vec3.create(0.0, 0.0, dz);\n        else\n            if (Math.abs(dy) < Math.abs(dz))\n                return vec3.create(0.0, dy, 0.0);\n            else\n                return vec3.create(0.0, 0.0, dz);\n    }\n}\n","import { Logic } from \"./Logic\";\n\nexport class Dialog {\n    private logic: Logic;\n    private dialogButton: SVGSVGElement;\n    private htmlDialog: HTMLDialogElement;\n\n\n    private timerInput: HTMLInputElement;\n    private timerButton: HTMLButtonElement;\n\n    private moveSpeedInput: HTMLInputElement;\n    private moveSpeedLabel: HTMLLabelElement;\n\n    private mouseSensitivtyInput: HTMLInputElement;\n    private mouseSensitivtyLabel: HTMLLabelElement;\n\n    public constructor(logic: Logic, dialogButton: SVGSVGElement, htmlDialog: HTMLDialogElement) {\n        this.logic = logic;\n        this.dialogButton = dialogButton;\n        this.htmlDialog = htmlDialog;\n\n        this.dialogButton.onclick = this.onDialogButton;\n        this.htmlDialog.onclick = this.onDialogClicked;\n\n\n        const configsDiv = this.htmlDialog.children[0].children[0];\n\n        const timerDiv = configsDiv.children[0];\n        this.timerInput = <HTMLInputElement>timerDiv.children[1];\n        this.timerInput.onchange = this.onTimerChange;\n        this.timerButton = <HTMLButtonElement>timerDiv.children[2];\n        this.timerButton.onclick = this.onTimerButtonClicked;\n\n        const moveSpeedDiv = configsDiv.children[1];\n        this.moveSpeedInput = <HTMLInputElement>moveSpeedDiv.children[1];\n        this.moveSpeedInput.oninput = this.onMoveSpeedChanged;\n        this.moveSpeedLabel = <HTMLLabelElement>moveSpeedDiv.children[2];\n\n        const mouseSensitivtyDiv = configsDiv.children[2];\n        this.mouseSensitivtyInput = <HTMLInputElement>mouseSensitivtyDiv.children[1];\n        this.mouseSensitivtyInput.oninput = this.onMouseSensitivtyChanged;\n        this.mouseSensitivtyLabel = <HTMLLabelElement>mouseSensitivtyDiv.children[2];\n\n\n        this.moveSpeedInput.value = logic.moveSpeed.toString();\n        this.moveSpeedLabel.textContent = this.moveSpeedInput.value;\n\n        this.mouseSensitivtyInput.value = logic.mouseSensitivity.toString();\n        this.mouseSensitivtyLabel.textContent = this.mouseSensitivtyInput.value;\n    }\n\n    private onDialogButton = (e: MouseEvent) => {\n        const time = this.logic.timeout - Date.now();\n        this.timerInput.value = time > 0 ? time.toString() : \"0\";\n\n        this.htmlDialog.showModal();\n    }\n\n    private onDialogClicked = (e: MouseEvent) => {\n        const rect = this.htmlDialog.getBoundingClientRect();\n        const rectBottom = rect.top + rect.height;\n        const rectRight = rect.left + rect.width;\n        if (e.clientY < rect.top || e.clientY > rectBottom || e.clientX < rect.left || e.clientX > rectRight)\n            this.htmlDialog.close();\n    }\n\n\n    private onTimerChange = (e: Event) => {\n        if (/^\\d+$/.test(this.timerInput.value))\n            this.timerInput.style.borderColor = \"#888\";\n        else\n            this.timerInput.style.borderColor = \"#F22\";\n    }\n\n    private onTimerButtonClicked = (e: MouseEvent) => {\n        if (!/^\\d+$/.test(this.timerInput.value))\n            return;\n\n        this.timerInput.style.borderColor = \"#2F2\";\n        this.dialogButton.removeAttribute(\"timeout\");\n\n        this.logic.timeout = Date.now() + Number.parseInt(this.timerInput.value);\n        localStorage.setItem(\"timeout\", this.logic.timeout.toString());\n    }\n\n    private onMoveSpeedChanged = (e: Event) => {\n        const value = (<HTMLInputElement>e.target).value;\n\n        this.moveSpeedLabel.textContent = value;\n        this.logic.moveSpeed = Number.parseFloat(value);\n        localStorage.setItem(\"moveSpeed\", value);\n    }\n\n    private onMouseSensitivtyChanged = (e: Event) => {\n        const value = (<HTMLInputElement>e.target).value;\n\n        this.mouseSensitivtyLabel.textContent = value;\n        this.logic.mouseSensitivity = Number.parseFloat(value);\n        localStorage.setItem(\"mouseSensitivity\", value);\n    }\n}\n","import { Renderer } from \"../Rendering/Renderer\";\nimport { Mesh } from \"../Rendering/Mesh\";\nimport { BoxCollider } from \"./BoxCollider\";\nimport { Mat4, mat4, Vec3, vec3 } from \"wgpu-matrix\";\n\nexport class Logic {\n    private static SPEED_MULTIPLIER = 5;\n\n\n    private renderer: Renderer;\n    private htmlCanvas: HTMLCanvasElement;\n    private dialogButton: SVGSVGElement;\n\n    private stateHasChanged: boolean = false;\n\n    private modelBuffer: Float32Array = new Float32Array(Renderer.OBJECT_BUFFER_SIZE * 16);\n    private modelBufferCount: number = 0;\n    private boxColliderBuffer: BoxCollider[] = new Array<BoxCollider>(Renderer.OBJECT_BUFFER_SIZE);\n    private boxColliderCount: number = 0;\n\n    private viewPos: Vec3;\n    private viewRotation: Vec3;\n    private view: Mat4;\n\n    private projectionFieldOfView: number = 1.0;\n    private projection: Mat4;\n\n    private brightnessTimer: number = 0.0;\n    private colorTimer: number = 0.0;\n    private lightDirectionTimer: number = 0.0;\n\n    // configs\n    public timeout: number;\n    public moveSpeed: number;\n    public mouseSensitivity: number;\n\n\n    public constructor(renderer: Renderer, htmlCanvas: HTMLCanvasElement, dialogButton: SVGSVGElement) {\n        this.renderer = renderer;\n        this.htmlCanvas = htmlCanvas;\n        this.dialogButton = dialogButton;\n\n        for (let i = 0; i < this.boxColliderBuffer.length; i++)\n            this.boxColliderBuffer[i] = new BoxCollider(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\n        this.view = mat4.identity();\n        this.viewPos = vec3.zero();\n        this.viewPos[2] = -3;\n        this.viewRotation = vec3.zero();\n\n        this.projection = mat4.create();\n        this.zoomCamera(0);\n\n        this.renderer.view = this.view;\n        this.renderer.projection = this.projection;\n\n        // configs\n        const timeoutValue = localStorage.getItem(\"timeout\");\n        if (timeoutValue !== null)\n            this.timeout = Number.parseInt(timeoutValue);\n        else\n            this.timeout = Date.now() + 10 * 60 * 1000;\n\n        const moveSpeedValue = localStorage.getItem(\"moveSpeed\");\n        if (moveSpeedValue !== null)\n            this.moveSpeed = Number.parseFloat(moveSpeedValue);\n        else\n            this.moveSpeed = 1;\n\n        const mouseSensitivityValue = localStorage.getItem(\"mouseSensitivity\");\n        if (mouseSensitivityValue !== null)\n            this.mouseSensitivity = Number.parseFloat(mouseSensitivityValue);\n        else\n            this.mouseSensitivity = 1;\n\n        this.physicsLoop();\n        window.setInterval(this.physicsLoop, 1000.0 / 120.0);\n        this.renderLoop();\n    }\n\n    private physicsLoop = () => {\n        this.stateHasChanged = true;\n\n        // creates also the digits BoxColliders\n        this.createDigitModels();\n\n        // camera movement\n        {\n            const speed = this.moveFast ? Logic.SPEED_MULTIPLIER * 0.1 * this.moveSpeed : 0.1 * this.moveSpeed;\n            const xMovement = -Math.sin(this.viewRotation[0]) * speed;\n            const zMovement = Math.cos(this.viewRotation[0]) * speed;\n\n            if (this.moveForward) {\n                this.viewPos[0] += xMovement;\n                this.viewPos[2] += zMovement;\n            }\n            if (this.moveBackward) {\n                this.viewPos[0] -= xMovement;\n                this.viewPos[2] -= zMovement;\n            }\n            if (this.moveLeft) {\n                this.viewPos[0] += zMovement;\n                this.viewPos[2] -= xMovement;\n            }\n            if (this.moveRight) {\n                this.viewPos[0] -= zMovement;\n                this.viewPos[2] += xMovement;\n            }\n            if (this.moveUp)\n                this.viewPos[1] -= speed;\n            if (this.moveDown)\n                this.viewPos[1] += speed;\n\n            this.handleCameraCollision();\n\n            mat4.identity(this.view);\n            mat4.rotateX(this.view, this.viewRotation[1], this.view);\n            mat4.rotateY(this.view, this.viewRotation[0], this.view);\n            mat4.translate(this.view, this.viewPos, this.view);\n        }\n\n        this.renderer.view = this.view;\n        this.renderer.projection = this.projection;\n\n\n        // uniforms\n\n        this.brightnessTimer += 0.005;\n        if (this.brightnessTimer > 2.0 * Math.PI)\n            this.brightnessTimer -= 2.0 * Math.PI;\n        const brightness = Math.sin(this.brightnessTimer) / 4.0 + 0.75;\n        this.renderer.brightness = brightness;\n\n        this.colorTimer += 0.001;\n        if (this.colorTimer > 1.0)\n            this.colorTimer -= 1.0\n        this.renderer.colorRotate = this.colorTimer;\n\n        this.lightDirectionTimer += 0.002;\n        if (this.lightDirectionTimer > 2.0 * Math.PI)\n            this.lightDirectionTimer -= 2.0 * Math.PI;\n        const lightDirectionY = 0.25 + Math.cos(this.lightDirectionTimer) / 8.0;\n        const sinY = Math.sin(Math.acos(lightDirectionY));\n        const lightDirectionX = Math.cos(this.lightDirectionTimer) * sinY;\n        const lightDirectionZ = Math.sin(this.lightDirectionTimer) * sinY;\n        this.renderer.lightDirection = vec3.create(lightDirectionX, lightDirectionY, lightDirectionZ);\n    }\n\n    private renderLoop = () => {\n        try {\n            if (this.windowResized) {\n                this.renderer.renewRenderTextures();\n                this.windowResized = false;\n            }\n            else if (!this.stateHasChanged)\n                return;\n\n            this.renderer.renderStart();\n            {\n                this.renderer.setObjectShader();\n                {\n                    this.renderer.renderLittleSphere();\n                    this.renderer.renderSphereCubes();\n                    this.renderer.renderDigits(this.modelBuffer.subarray(0, this.modelBufferCount).buffer);\n                }\n\n                this.renderer.setBackgroundShader();\n                {\n                    this.renderer.renderBeckgound();\n                }\n            }\n            this.renderer.renderEnd();\n        }\n        finally {\n            this.stateHasChanged = false;\n            requestAnimationFrame(this.renderLoop);\n        }\n    }\n\n    private handleCameraCollision() {\n        if (   -25 < this.viewPos[1] && this.viewPos[1] < 25\n            && 198 < this.viewPos[2] && this.viewPos[2] < 202) {\n            // digits area\n\n            const cameraCollider = BoxCollider.create(this.viewPos, 0.5);\n            for (let i = 0; i < this.boxColliderCount; i++) {\n                const digitCollider = this.boxColliderBuffer[i];\n                if (digitCollider.hasCollision(cameraCollider)) {\n                    const pushAmount: Vec3 = digitCollider.handleCollision(cameraCollider);\n                    this.viewPos[0] += pushAmount[0];\n                    this.viewPos[1] += pushAmount[1];\n                    this.viewPos[2] += pushAmount[2];\n                    return;\n                }\n            }\n\n            return;\n        }\n\n        if (   -202 < this.viewPos[0] && this.viewPos[0] < 202\n            && -202 < this.viewPos[1] && this.viewPos[1] < 202\n            &&  298 < this.viewPos[2] && this.viewPos[2] < 702) {\n            // little sphere and sphere cubes area\n\n            const cameraCollider = BoxCollider.create(this.viewPos, 0.5);\n            const sphereBoxCollider = BoxCollider.create(vec3.create(0.0, 0.0, 500.0), 20.0);\n            if (sphereBoxCollider.hasCollision(cameraCollider)) {\n                // camera and little sphere are both sphere colliders at this point\n                const lengthX = this.viewPos[0] - 0.0;\n                const lengthY = this.viewPos[1] - 0.0;\n                const lengthZ = this.viewPos[2] - 500.0;\n                const distance = Math.sqrt(lengthX * lengthX + lengthY * lengthY + lengthZ * lengthZ);\n\n                const radius: number = 20.0;\n                const otherRadius: number = 1.0;\n\n                const minDistance = radius + otherRadius;\n                const distanceDif = minDistance - distance;\n                if (distanceDif <= 0)\n                    return;\n\n\n                this.viewPos[0] += lengthX / distance * distanceDif;\n                this.viewPos[1] += lengthY / distance * distanceDif;\n                this.viewPos[2] += lengthZ / distance * distanceDif;\n\n                return;\n            }\n\n            // sphere cubes\n            for (let i = 0; i < Mesh.sphere.vertixCount; i++) {\n                const cubeCollider = BoxCollider.create(vec3.create(Mesh.sphere.vertices[8 * i] * -200, Mesh.sphere.vertices[8 * i + 1] * -200, Mesh.sphere.vertices[8 * i + 2] * -200 + 500), 0.5);\n                if (cubeCollider.hasCollision(cameraCollider)) {\n                    const pushAmount: Vec3 = cubeCollider.handleCollision(cameraCollider);\n                    this.viewPos[0] += pushAmount[0];\n                    this.viewPos[1] += pushAmount[1];\n                    this.viewPos[2] += pushAmount[2];\n                    return;\n                }\n            }\n\n            return;\n        }\n    }\n\n\n    private createDigitModels(): void {\n        const DIGIT_LINE = 10.0;\n        const SPACING = 40.0;\n\n        const reset = (model: Mat4, translateX: number) => {\n            mat4.identity(model);\n            mat4.translate(model, [translateX, 0, -200], model);\n            return model;\n        }\n\n\n        const topBar = (model: Mat4) => {\n            mat4.translate(model, [0.0, 2.0 * DIGIT_LINE + 2.0, 0.0], model);\n            mat4.scale(model, [DIGIT_LINE, 1.0, 1.0], model);\n\n            const boxCollider = this.boxColliderBuffer[this.boxColliderCount++];\n            boxCollider.ax = -model[12] - DIGIT_LINE;\n            boxCollider.bx = -model[12] + DIGIT_LINE;\n            boxCollider.ay = -model[13] - 1.0;\n            boxCollider.by = -model[13] + 1.0;\n            boxCollider.az = -model[14] - 1.0;\n            boxCollider.bz = -model[14] + 1.0;\n\n            return model;\n        }\n\n        const middleBar = (model: Mat4) => {\n            mat4.scale(model, [DIGIT_LINE, 1.0, 1.0], model);\n\n            const boxCollider = this.boxColliderBuffer[this.boxColliderCount++];\n            boxCollider.ax = -model[12] - DIGIT_LINE;\n            boxCollider.bx = -model[12] + DIGIT_LINE;\n            boxCollider.ay = -model[13] - 1.0;\n            boxCollider.by = -model[13] + 1.0;\n            boxCollider.az = -model[14] - 1.0;\n            boxCollider.bz = -model[14] + 1.0;\n\n            return model;\n        }\n\n        const bottomBar = (model: Mat4) => {\n            mat4.translate(model, [0.0, -2.0 * DIGIT_LINE - 2.0, 0.0], model);\n            mat4.scale(model, [DIGIT_LINE, 1.0, 1.0], model);\n\n            const boxCollider = this.boxColliderBuffer[this.boxColliderCount++];\n            boxCollider.ax = -model[12] - DIGIT_LINE;\n            boxCollider.bx = -model[12] + DIGIT_LINE;\n            boxCollider.ay = -model[13] - 1.0;\n            boxCollider.by = -model[13] + 1.0;\n            boxCollider.az = -model[14] - 1.0;\n            boxCollider.bz = -model[14] + 1.0;\n\n            return model;\n        }\n\n        const upperLeftBar = (model: Mat4) => {\n            mat4.translate(model, [-DIGIT_LINE - 1.0, DIGIT_LINE + 1.0, 0.0], model);\n            mat4.scale(model, [1.0, DIGIT_LINE, 1.0], model);\n\n            const boxCollider = this.boxColliderBuffer[this.boxColliderCount++];\n            boxCollider.ax = -model[12] - 1.0;\n            boxCollider.bx = -model[12] + 1.0;\n            boxCollider.ay = -model[13] - DIGIT_LINE;\n            boxCollider.by = -model[13] + DIGIT_LINE;\n            boxCollider.az = -model[14] - 1.0;\n            boxCollider.bz = -model[14] + 1.0;\n\n            return model;\n        }\n\n        const upperRightBar = (model: Mat4) => {\n            mat4.translate(model, [DIGIT_LINE + 1.0, DIGIT_LINE + 1.0, 0.0], model);\n            mat4.scale(model, [1.0, DIGIT_LINE, 1.0], model);\n\n            const boxCollider = this.boxColliderBuffer[this.boxColliderCount++];\n            boxCollider.ax = -model[12] - 1.0;\n            boxCollider.bx = -model[12] + 1.0;\n            boxCollider.ay = -model[13] - DIGIT_LINE;\n            boxCollider.by = -model[13] + DIGIT_LINE;\n            boxCollider.az = -model[14] - 1.0;\n            boxCollider.bz = -model[14] + 1.0;\n\n            return model;\n        }\n\n        const lowerLeftBar = (model: Mat4) => {\n            mat4.translate(model, [-DIGIT_LINE - 1.0, -DIGIT_LINE - 1.0, 0.0], model);\n            mat4.scale(model, [1.0, DIGIT_LINE, 1.0], model);\n\n            const boxCollider = this.boxColliderBuffer[this.boxColliderCount++];\n            boxCollider.ax = -model[12] - 1.0;\n            boxCollider.bx = -model[12] + 1.0;\n            boxCollider.ay = -model[13] - DIGIT_LINE;\n            boxCollider.by = -model[13] + DIGIT_LINE;\n            boxCollider.az = -model[14] - 1.0;\n            boxCollider.bz = -model[14] + 1.0;\n\n            return model;\n        }\n\n        const lowerRightBar = (model: Mat4) => {\n            mat4.translate(model, [DIGIT_LINE + 1.0, -DIGIT_LINE - 1.0, 0.0], model);\n            mat4.scale(model, [1.0, DIGIT_LINE, 1.0], model);\n\n            const boxCollider = this.boxColliderBuffer[this.boxColliderCount++];\n            boxCollider.ax = -model[12] - 1.0;\n            boxCollider.bx = -model[12] + 1.0;\n            boxCollider.ay = -model[13] - DIGIT_LINE;\n            boxCollider.by = -model[13] + DIGIT_LINE;\n            boxCollider.az = -model[14] - 1.0;\n            boxCollider.bz = -model[14] + 1.0;\n\n            return model;\n        }\n\n\n        this.boxColliderCount = 0;\n        let time = this.timeout - Date.now();\n        if (time < 0) {\n            this.modelBufferCount = 6 * 16;\n            const model = mat4.create();\n\n            this.modelBuffer.set(topBar(reset(model, 0)), 0);\n            this.modelBuffer.set(bottomBar(reset(model, 0)), 1 * 16);\n            this.modelBuffer.set(upperLeftBar(reset(model, 0)), 2 * 16);\n            this.modelBuffer.set(upperRightBar(reset(model, 0)), 3 * 16);\n            this.modelBuffer.set(lowerLeftBar(reset(model, 0)), 4 * 16);\n            this.modelBuffer.set(lowerRightBar(reset(model, 0)), 5 * 16);\n\n            // dialog button timeout animation\n            this.dialogButton.setAttribute(\"timeout\", \"\");\n        }\n\n        const digits: number[] = [];\n        let barCount = 0;\n        do {\n            const digit = time % 10;\n            digits.push(digit);\n            switch(digit) {\n                case 0: barCount += 6; break;\n                case 1: barCount += 2; break;\n                case 2: barCount += 5; break;\n                case 3: barCount += 5; break;\n                case 4: barCount += 4; break;\n                case 5: barCount += 5; break;\n                case 6: barCount += 6; break;\n                case 7: barCount += 3; break;\n                case 8: barCount += 7; break;\n                case 9: barCount += 6; break;\n            }\n\n            time = Math.floor(time / 10);\n        } while (time > 0);\n\n\n        this.modelBufferCount = barCount * 16;\n        const model = mat4.create();\n        const spaceOffset = (digits.length - 1) / 2;\n        let resultIndex = -16;\n        for (let i = 0; i < digits.length; i++) {\n            const position = (spaceOffset - i) * SPACING;\n            switch(digits[i]) {\n                case 0:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(bottomBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 1:\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 2:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(middleBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(bottomBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerLeftBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 3:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(middleBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(bottomBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 4:\n                    this.modelBuffer.set(middleBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 5:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(middleBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(bottomBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 6:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(middleBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(bottomBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 7:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 8:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(middleBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(bottomBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n\n                case 9:\n                    this.modelBuffer.set(topBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(middleBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(bottomBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperLeftBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(upperRightBar(reset(model, position)), resultIndex += 16);\n                    this.modelBuffer.set(lowerRightBar(reset(model, position)), resultIndex += 16);\n                    break;\n            }\n        }\n    }\n\n\n    // controller inputs\n\n    public moveForward: boolean = false;\n    public moveBackward: boolean = false;\n    public moveLeft: boolean = false;\n    public moveRight: boolean = false;\n    public moveUp: boolean = false;\n    public moveDown: boolean = false;\n    public moveFast: boolean = false;\n\n    private windowResized: boolean = false;\n    public setWindowResized() { this.windowResized = true; }\n\n    public rotateCamera(yaw: number, pitch: number) {\n        const sensitivity = 0.001 * this.mouseSensitivity;\n\n        this.viewRotation[0] += sensitivity * yaw;\n        if (this.viewRotation[0] < 0)\n            this.viewRotation[0] += 2 * Math.PI;\n        else if (this.viewRotation[0] > 2 * Math.PI)\n            this.viewRotation[0] -= 2 * Math.PI;\n\n        this.viewRotation[1] += sensitivity * pitch;\n        if (this.viewRotation[1] < -Math.PI / 2)\n            this.viewRotation[1] = -Math.PI / 2;\n        else if (this.viewRotation[1] > Math.PI / 2)\n            this.viewRotation[1] = Math.PI / 2;\n    }\n\n    public zoomCamera(zoom: number) {\n        this.projectionFieldOfView += 0.01 * zoom;\n        if (this.projectionFieldOfView < 0.3)\n            this.projectionFieldOfView = 0.3;\n        else if (this.projectionFieldOfView > 1.6)\n            this.projectionFieldOfView = 1.6;\n\n        mat4.perspective(this.projectionFieldOfView, this.htmlCanvas.width / this.htmlCanvas.height, 0.1, 500.0, this.projection);\n    }\n}\n","export class ImageLoader {\n    private canvas: HTMLCanvasElement = document.createElement(\"canvas\");\n    private context: CanvasRenderingContext2D = this.canvas.getContext(\"2d\")!;\n    private image: HTMLImageElement = new Image();\n\n\n    public async loadPng(url: string): Promise<ImageBitmap> {\n        const blob = await this.fetchImage(url);\n        return await createImageBitmap(blob);\n    }\n\n    public async loadSvg(url: string, width: number, height: number): Promise<ImageBitmap> {\n        const svgBlob = await this.fetchImage(url);\n        const pngBlob = await this.svgToPng(svgBlob, width, height);\n        return await createImageBitmap(pngBlob);\n    }\n\n    public async loadSvgMipmaps(url: string, width: number, height: number, mipLevelCount: number): Promise<ImageBitmap[]> {\n        const svgBlob = await this.fetchImage(url);\n\n        const result = Array<ImageBitmap>(mipLevelCount);\n        for (let i = 0; i < mipLevelCount; i++) {\n            const pngBlob = await this.svgToPng(svgBlob, width, height);\n            result[i] = await createImageBitmap(pngBlob);\n            width >>= 1;\n            height >>= 1;\n        }\n\n        return result;\n    }\n\n\n    private async fetchImage(url: string): Promise<Blob> {\n        const response = await fetch(url);\n        if (!response.ok)\n            throw new Error(`fetch error '${url}': ${response.status}`);\n\n        return await response.blob();\n    }\n\n    private async svgToPng(svgBlob: Blob, width: number, height: number) {\n        return await new Promise<Blob>((resolve, reject) => {\n            this.image.onload = () => {\n                this.canvas.width = width;\n                this.canvas.height = height;\n                this.context.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);\n                URL.revokeObjectURL(this.image.src);\n                this.canvas.toBlob((blob) => blob !== null ? resolve(blob) : reject(\"'canvas.toBlob(...)' failed: it returned null\"));\n            }\n            this.image.src = URL.createObjectURL(svgBlob);\n        });\n    }\n}\n","export class Mesh {\n    public get vertices(): Float32Array { return this._vertices; }\n    public _vertices: Float32Array;\n\n    public get indices(): Uint16Array { return this._indices; }\n    public _indices: Uint16Array;\n\n    public get vertixCount(): number { return this._vertixCount; }\n    public _vertixCount: number;\n\n    public get triangleCount(): number { return this._triangleCount; }\n    public _triangleCount: number;\n\n    private constructor(vertices: Float32Array, indices: Uint16Array) {\n        this._vertices = vertices;\n        this._indices = indices;\n        this._vertixCount = vertices.length / 8;\n        this._triangleCount = indices.length / 3;\n    }\n\n\n    public static get cube(): Mesh { return this._cube; }\n    private static _cube: Mesh = new Mesh(\n        new Float32Array([\n            // position          // normal          // texturePosition\n\n            // front\n            1.0,  1.0,  1.0,     0.0, 0.0, 1.0,     1.0, 1.0,  // 0  right-top-front\n            1.0, -1.0,  1.0,     0.0, 0.0, 1.0,     1.0, 0.0,  // 1  right-bottom-front\n            -1.0, -1.0,  1.0,    0.0, 0.0, 1.0,     0.0, 0.0,  // 2  left-bottom-front\n            -1.0, 1.0,  1.0,     0.0, 0.0, 1.0,     0.0, 1.0,  // 3  left-top-front\n\n            // top\n            1.0,  1.0, -1.0,     0.0, 1.0, 0.0,     1.0, 1.0,  // 4  right-top-back\n            1.0,  1.0,  1.0,     0.0, 1.0, 0.0,     1.0, 0.0,  // 5  right-top-front\n            -1.0,  1.0,  1.0,    0.0, 1.0, 0.0,     0.0, 0.0, // 6  left-top-front\n            -1.0,  1.0, -1.0,    0.0, 1.0, 0.0,     0.0, 1.0, // 7  left-top-back\n\n            // bottom\n            1.0, -1.0, 1.0,      0.0, -1.0, 0.0,    1.0, 1.0,   // 8  right-bottom-front\n            1.0, -1.0, -1.0,     0.0, -1.0, 0.0,    1.0, 0.0,  // 9  right-bottom-back\n            -1.0, -1.0, -1.0,    0.0, -1.0, 0.0,    0.0, 0.0, // 10 left-bottom-back\n            -1.0, -1.0, 1.0,     0.0, -1.0, 0.0,    0.0, 1.0,  // 11 left-bottom-front\n\n            // left\n            -1.0, 1.0, 1.0,      -1.0, 0.0, 0.0,    1.0, 1.0, // 12 left-top-front\n            -1.0, -1.0, 1.0,     -1.0, 0.0, 0.0,    1.0, 0.0, // 13 left-bottom-front\n            -1.0, -1.0, -1.0,    -1.0, 0.0, 0.0,    0.0, 0.0, // 14 left-bottom-back\n            -1.0, 1.0, -1.0,     -1.0, 0.0, 0.0,    0.0, 1.0, // 15 left-top-back\n\n            // right\n            1.0, 1.0, -1.0,      1.0, 0.0, 0.0,     1.0, 1.0, // 16 right-top-back\n            1.0, -1.0, -1.0,     1.0, 0.0, 0.0,     1.0, 0.0, // 17 right-bottom-back\n            1.0, -1.0, 1.0,      1.0, 0.0, 0.0,     0.0, 0.0, // 18 right-bottom-front\n            1.0, 1.0, 1.0,       1.0, 0.0, 0.0,     0.0, 1.0, // 19 right-top-front\n\n            // back\n            -1.0, 1.0, -1.0,     0.0, 0.0, -1.0,    1.0, 1.0, // 20 left-top-back\n            -1.0, -1.0, -1.0,    0.0, 0.0, -1.0,    1.0, 0.0, // 21 left-bottom-back\n            1.0, -1.0, -1.0,     0.0, 0.0, -1.0,    0.0, 0.0, // 22 right-bottom-back\n            1.0, 1.0, -1.0,      0.0, 0.0, -1.0,    0.0, 1.0  // 23 right-top-back\n        ]),\n        new Uint16Array([\n            // front square\n            0, 1, 3,\n            1, 2, 3,\n            // top square\n            4, 5, 7,\n            5, 6, 7,\n            // bottom square\n            8, 9, 11,\n            9, 10, 11,\n            // left square\n            12, 13, 15,\n            13, 14, 15,\n            // right square\n            16, 17, 19,\n            17, 18, 19,\n            // back square\n            20, 21, 23,\n            21, 22, 23,\n        ])\n    );\n\n\n    private static _sphere: Mesh | null = null;\n    public static get sphere(): Mesh {\n        if (this._sphere === null)\n            this._sphere = Mesh.createSphere();\n\n        return this._sphere;\n    }\n\n    private static createSphere(): Mesh {\n        // number of vertices\n        const size = 10;\n        const longitude = size;\n        const latitude = size;\n\n        const circle45 = Math.sin(Math.PI / 4);\n\n\n        // angles\n\n        let horizintalAngles: {cos: number, sin: number}[] = new Array(longitude);\n        {\n            const hStep = Math.PI / (4 * (longitude + 1)); // PI/4 == 45°\n            let currentStep = hStep;\n            for (let i = 0; i < longitude; i++, currentStep += hStep)\n                horizintalAngles[i] = {cos: Math.cos(currentStep), sin: Math.sin(currentStep)};\n        }\n\n        let verticalAngles: {cos: number, sin: number}[];\n        if (longitude == latitude)\n            verticalAngles = horizintalAngles;\n        else {\n            verticalAngles = new Array(latitude);\n            {\n                const vStep = Math.PI / (4 * (latitude + 1)); // PI/4 == 45°\n                let currentStep = vStep;\n                for (let i = 0; i < latitude; i++, currentStep += vStep)\n                    verticalAngles[i] = {cos: Math.cos(currentStep), sin: Math.sin(currentStep)};\n            }\n        }\n\n\n\n        // vertexPos array\n\n        const horizontalLength = 8 * longitude + 9;\n        const verticalLength = 4 * latitude + 3;\n\n        const vertexPos: {x: number, y: number, z: number}[][] = new Array(verticalLength);\n        for (let i = 0; i < verticalLength; i++)\n            vertexPos[i] = new Array(horizontalLength);\n\n        const middle = 2 * latitude + 1;\n        {\n            // horizontal coordinates\n            const top = 2 * longitude + 2;\n            const left = 4 * longitude + 4;\n            const bottom = 6 * longitude + 6;\n            const right = 8 * longitude + 8;\n\n            vertexPos[middle][0] = {x: 1.0, y: 0.0, z: 0.0};                                      // right (start)\n            vertexPos[middle][0 + longitude + 1] = {x: circle45, y: 0.0, z: circle45};            // right-top\n            vertexPos[middle][top] = {x: 0.0, y: 0.0, z: 1.0};                                    // top\n            vertexPos[middle][top + longitude + 1] = {x: -circle45, y: 0.0, z: circle45};         // top-left\n            vertexPos[middle][left] = {x: -1.0, y: 0.0, z: 0.0};                                  // left\n            vertexPos[middle][left + longitude + 1] = {x: -circle45, y: 0.0, z: -circle45};       // left-bottom\n            vertexPos[middle][bottom] = {x: 0.0, y: 0.0, z: -1.0};                                // bottom\n            vertexPos[middle][bottom + longitude + 1] = {x: circle45, y: 0.0, z: -circle45};      // bottom-right\n            vertexPos[middle][right] = {x: 1.0, y: 0.0, z: 0.0};                                  // right (end)\n\n            for (let i = 1; i <= longitude; i++) {\n                const x = horizintalAngles[i - 1].cos;\n                const z = horizintalAngles[i - 1].sin;\n\n                vertexPos[middle][i] = {x: x, y: 0.0, z: z};\n                vertexPos[middle][top - i] = {x: z, y: 0.0, z: x};\n                vertexPos[middle][top + i] = {x: -z, y: 0.0, z: x};\n                vertexPos[middle][left - i] = {x: -x, y: 0.0, z: z};\n                vertexPos[middle][left + i] = {x: -x, y: 0.0, z: -z};\n                vertexPos[middle][bottom - i] = {x: -z, y: 0.0, z: -x};\n                vertexPos[middle][bottom + i] = {x: z, y: 0.0, z: -x};\n                vertexPos[middle][right - i] = {x: x, y: 0.0, z: -z};\n            }\n        }\n\n        const top45 = middle - latitude - 1;\n        const bottom45 = middle + latitude + 1;\n        for (let i = 0; i < horizontalLength; i++) {\n            const x = vertexPos[middle][i].x * circle45;\n            const z = vertexPos[middle][i].z * circle45;\n\n            vertexPos[top45][i] = {x: x, y: circle45, z: z};\n            vertexPos[bottom45][i] = {x: x, y: -circle45, z: z};\n        }\n\n        for (let i = 1; i <= latitude; i++) {\n            const y = verticalAngles[i - 1].cos;\n            const x = verticalAngles[i - 1].sin;\n\n            for (let j = 0; j < horizontalLength; j++) {\n                const xx = vertexPos[middle][j].x * x;\n                const zx = vertexPos[middle][j].z * x;\n                const xy = vertexPos[middle][j].x * y;\n                const zy = vertexPos[middle][j].z * y;\n                vertexPos[i - 1][j] = {x: xx, y: y, z: zx};\n                vertexPos[middle - i][j] = {x: xy, y: x, z: zy};\n                vertexPos[middle + i][j] = {x: xy, y: -x, z: zy};\n                vertexPos[verticalLength - i][j] = {x: xx, y: -y, z: zx};\n            }\n        }\n\n\n\n        // vertex array\n\n        const vertices: number[] = new Array(vertexPos.length * 8);\n        {\n            let index = 0;\n\n            const horizontalStep = 1.0 / (horizontalLength - 1.0);\n            const verticalStep = 1.0 / (verticalLength + 1.0);\n\n            // top vertices\n            {\n                let step = horizontalStep / 2.0;\n                for (let i = 0; i < horizontalLength - 1; i++) {\n                    vertices[index++] = 0.0;\n                    vertices[index++] = 1.0;\n                    vertices[index++] = 0.0;\n\n                    vertices[index++] = 0.0;\n                    vertices[index++] = 1.0;\n                    vertices[index++] = 0.0;\n\n                    vertices[index++] = step;\n                    vertices[index++] = 1.0;\n\n                    step += horizontalStep;\n                }\n            }\n\n            // middle vertices\n            {\n                let vStep = 1 - verticalStep;\n                for (let i = 0; i < verticalLength; i++) {\n                    let hStep = 0.0;\n                    for (let j = 0; j < horizontalLength; j++) {\n                        vertices[index++] = vertexPos[i][j].x;\n                        vertices[index++] = vertexPos[i][j].y;\n                        vertices[index++] = vertexPos[i][j].z;\n\n                        vertices[index++] = vertexPos[i][j].x;\n                        vertices[index++] = vertexPos[i][j].y;\n                        vertices[index++] = vertexPos[i][j].z;\n\n                        vertices[index++] = hStep;\n                        vertices[index++] = vStep;\n\n                        hStep += horizontalStep;\n                    }\n                    vStep -= verticalStep;\n                }\n            }\n\n            // bottom vertices\n            {\n                let step = horizontalStep / 2.0;\n                for (let i = 0; i < horizontalLength - 1; i++) {\n                    vertices[index++] = 0.0;\n                    vertices[index++] = -1.0;\n                    vertices[index++] = 0.0;\n\n                    vertices[index++] = 0.0;\n                    vertices[index++] = -1.0;\n                    vertices[index++] = 0.0;\n\n                    vertices[index++] = step;\n                    vertices[index++] = 0.0;\n\n                    step += horizontalStep;\n                }\n            }\n        }\n\n\n\n        // indices array\n\n        const offset = horizontalLength - 1;\n        const indices: number[] = new Array(3 * (2 * offset + 2 * (verticalLength - 1) * (horizontalLength - 1)));\n        {\n            let index = 0;\n\n            // top triangles\n            for (let i = 0; i < offset; i++) {\n                indices[index++] = i;\n                indices[index++] = offset + i;\n                indices[index++] = offset + i + 1;\n            }\n\n            // middle squares\n            for (let i = 0; i < verticalLength - 1; i++)\n                for (let j = 0; j < horizontalLength - 1; j++) {\n                    const topLeft = offset + horizontalLength * i + j;\n                    const topRight = offset + horizontalLength * i + j + 1;\n                    const bottomLeft = offset + horizontalLength * (i + 1) + j;\n                    const bottomRight = offset + horizontalLength * (i + 1) + j + 1;\n\n                    indices[index++] = topRight;\n                    indices[index++] = topLeft;\n                    indices[index++] = bottomRight;\n\n                    indices[index++] = bottomRight;\n                    indices[index++] = topLeft;\n                    indices[index++] = bottomLeft;\n                }\n\n            // bottom triangles\n            const totalLength = horizontalLength * verticalLength;\n            const bottomStart = offset + totalLength;\n            const lastArray = offset + totalLength - horizontalLength;\n            for (let i = 0; i < offset; i++) {\n                indices[index++] = lastArray + i;\n                indices[index++] = bottomStart + i;\n                indices[index++] = lastArray + i + 1;\n            }\n        }\n\n        return new Mesh(new Float32Array(vertices), new Uint16Array(indices));\n    }\n}\n","import SHADER_CODE from \"./Shader/shaders.wgsl\";\nimport { Mesh } from \"./Mesh\";\nimport { ImageLoader } from \"./ImageLoader\";\nimport { Mat4, mat4, Vec3, vec3 } from \"wgpu-matrix\";\n\nexport class Renderer {\n    private static COLOR_FORMAT: GPUTextureFormat = \"bgra8unorm\";\n    private static DEPTH_FORMAT: GPUTextureFormat = \"depth24plus-stencil8\";\n    private static SAMPLE_COUNT: number = 4;\n    public static OBJECT_BUFFER_SIZE = 512;\n\n    // environment/window\n    private htmlCanvas: HTMLCanvasElement;\n    private canvasContext: GPUCanvasContext;\n    private gpuAdapter: GPUAdapter;\n    private device: GPUDevice;\n\n    // pipeline\n    private gpuBindGroup: GPUBindGroup;\n    private objectRenderPipeline: GPURenderPipeline;\n    private backgroundRenderPipeline: GPURenderPipeline;\n    private renderPassDescriptor: GPURenderPassDescriptor;\n\n    // gpu buffers\n    private cubeVertexBuffer: GPUBuffer;\n    private cubeIndexBuffer: GPUBuffer;\n    private sphereVertexBuffer: GPUBuffer;\n    private sphereIndexBuffer: GPUBuffer;\n\n    // gpu texture\n    private texture: GPUTexture;\n    private textureSampler: GPUSampler;\n\n    // gpu model matrices buffer\n    private modelMatrices: GPUBuffer;\n\n    // gpu uniforms\n    private transformationUniform: GPUBuffer;\n    private brightnessUniform: GPUBuffer;\n    private colorRotateUnifrom: GPUBuffer;\n    private lightDirectionUniform: GPUBuffer;\n\n\n    public static async create(canvas: HTMLCanvasElement): Promise<Renderer> {\n        // browser support\n        if (navigator.gpu === undefined)\n            throw new Error(\"WebGPU is not supported/enabled in your browser\");\n\n        // gpu device\n        const gpuAdapter = (await navigator.gpu.requestAdapter())!;\n        const device = await gpuAdapter.requestDevice();\n\n        // compile shader module\n        const shaderModule = device.createShaderModule({code: SHADER_CODE});\n        {\n            const compilationInfo = await shaderModule.getCompilationInfo();\n            for (const message of compilationInfo.messages)\n                if (message.type === \"error\")\n                    throw new Error(\"aborted => shader module compilation error(s)\");\n        }\n\n        // textures\n        const imageLoader = new ImageLoader();\n        const bitmaps = await imageLoader.loadSvgMipmaps(\"img/rose.svg\", 4096, 4096, 6);\n\n        return new Renderer(canvas, gpuAdapter, device, shaderModule, bitmaps);\n    }\n\n    private constructor(canvas: HTMLCanvasElement, gpuAdapter: GPUAdapter, device: GPUDevice, shaderModule: GPUShaderModule, bitmaps: ImageBitmap[]) {\n        this.htmlCanvas = canvas;\n        this.gpuAdapter = gpuAdapter;\n        this.device = device;\n\n        this.canvasContext = this.htmlCanvas.getContext(\"webgpu\")!;\n        this.canvasContext.configure({\n            device: this.device,\n            format: Renderer.COLOR_FORMAT,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n        });\n\n        this.renderPassDescriptor = {\n            colorAttachments: <Iterable<GPURenderPassColorAttachment>>[{\n                view: this.createMultisampleTexture(),\n                resolveTarget: null,\n                loadOp: \"clear\",\n                clearValue: [0.3, 0.3, 0.3, 1],\n                storeOp: \"store\",\n            }],\n            depthStencilAttachment: {\n                view: this.createDepthStencilView(),\n                depthLoadOp: \"clear\",\n                depthClearValue: 1.0,\n                depthStoreOp: \"store\",\n                stencilLoadOp: \"clear\",\n                stencilClearValue: 0,\n                stencilStoreOp: \"store\"\n            }\n        };\n\n\n        // create gpu buffers\n\n        // cube\n        this.cubeVertexBuffer = this.device.createBuffer({\n            size: Mesh.cube.vertices.byteLength,\n            usage: GPUBufferUsage.VERTEX,\n            mappedAtCreation: true\n        });\n        new Float32Array(this.cubeVertexBuffer.getMappedRange()).set(Mesh.cube.vertices);\n        this.cubeVertexBuffer.unmap();\n\n        this.cubeIndexBuffer = this.device.createBuffer({\n            size: Mesh.cube.indices.byteLength,\n            usage: GPUBufferUsage.INDEX,\n            mappedAtCreation: true\n        });\n        new Uint16Array(this.cubeIndexBuffer.getMappedRange()).set(Mesh.cube.indices);\n        this.cubeIndexBuffer.unmap();\n\n        // sphere\n        this.sphereVertexBuffer = this.device.createBuffer({\n            size: Mesh.sphere.vertices.byteLength,\n            usage: GPUBufferUsage.VERTEX,\n            mappedAtCreation: true\n        });\n        new Float32Array(this.sphereVertexBuffer.getMappedRange()).set(Mesh.sphere.vertices);\n        this.sphereVertexBuffer.unmap();\n\n        this.sphereIndexBuffer = this.device.createBuffer({\n            size: Mesh.sphere.indices.byteLength,\n            usage: GPUBufferUsage.INDEX,\n            mappedAtCreation: true\n        });\n        new Uint16Array(this.sphereIndexBuffer.getMappedRange()).set(Mesh.sphere.indices);\n        this.sphereIndexBuffer.unmap();\n\n        // texture\n        const textureDescriptor: GPUTextureDescriptor = {\n            size: {\n                width: bitmaps[0].width,\n                height: bitmaps[0].height\n            },\n            format: Renderer.COLOR_FORMAT,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n            mipLevelCount: bitmaps.length\n        };\n        this.texture = this.device.createTexture(textureDescriptor);\n        for (let i = 0; i < bitmaps.length; i++)\n            this.device.queue.copyExternalImageToTexture({source: bitmaps[i]}, {texture: this.texture, mipLevel: i}, {width: bitmaps[i].width, height: bitmaps[i].height});\n\n        this.textureSampler = this.device.createSampler({\n            addressModeU: \"clamp-to-edge\",\n            addressModeV: \"clamp-to-edge\",\n            magFilter: \"nearest\",\n            minFilter: \"nearest\",\n            mipmapFilter: \"nearest\",\n            maxAnisotropy: 1\n        });\n\n        // model matrices\n        const modelArray = new Float32Array((1 + Mesh.sphere.vertixCount) * 16); // (little sphere + sphere cubes + dynamic digits buffer) * matrix size\n        {\n            const temp = mat4.identity();\n            // little sphere\n            mat4.translate(temp, [0.0, 0.0, -500.0], temp);\n            mat4.scale(temp, [20.0, 20.0, 20.0], temp)\n            modelArray.set(temp, 0);\n            // sphere cubes\n            for (let i = 0; i < Mesh.sphere.vertixCount; i++) {\n                mat4.identity(temp);\n                mat4.translate(temp, [Mesh.sphere.vertices[8 * i] * 200, Mesh.sphere.vertices[8 * i + 1] * 200, Mesh.sphere.vertices[8 * i + 2] * 200 - 500], temp);\n                mat4.scale(temp, [0.5, 0.5, 0.5], temp);\n                modelArray.set(temp, (i + 1) * 16);\n            }\n        }\n        this.modelMatrices = this.device.createBuffer({\n            size: (1 + Mesh.sphere.vertixCount + Renderer.OBJECT_BUFFER_SIZE) * 16 * 4, // (little sphere + sphere cubes + dynamic digits buffer) * matrix size\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true\n        });\n        new Float32Array(this.modelMatrices.getMappedRange()).set(modelArray);\n        this.modelMatrices.unmap();\n\n        // uniforms\n        this.transformationUniform = device.createBuffer({\n            size: 2 * 16 * 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n\n        this.brightnessUniform = device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n\n        this.colorRotateUnifrom = device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n\n        this.lightDirectionUniform = device.createBuffer({\n            size: 3 * 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n\n\n        // create render pipeline\n\n        const bindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {   // textrue\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {}\n                },\n                {   // sampler\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {}\n                },\n                {   // modelMatrices\n                    binding: 2,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: \"read-only-storage\",\n                        hasDynamicOffset: false\n                    }\n                },\n                {   // transformation\n                    binding: 3,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: {}\n                },\n                {   // brightness\n                    binding: 4,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {}\n                },\n                {   // colorRotate\n                    binding: 5,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {}\n                },\n                {   // lightDirection\n                    binding: 6,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {}\n                }\n            ]\n        });\n        this.gpuBindGroup = this.device.createBindGroup({\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.texture.createView({\n                        format: Renderer.COLOR_FORMAT,\n                        dimension: \"2d\",\n                        aspect: \"all\",\n                        baseMipLevel: 0,\n                        mipLevelCount: 1,\n                        baseArrayLayer: 0,\n                        arrayLayerCount: 1\n                    })\n                },\n                {\n                    binding: 1,\n                    resource: this.textureSampler\n                },\n                {\n                    binding: 2,\n                    resource: { buffer: this.modelMatrices }\n                },\n                {\n                    binding: 3,\n                    resource: { buffer: this.transformationUniform }\n                },\n                {\n                    binding: 4,\n                    resource: { buffer: this.brightnessUniform }\n                },\n                {\n                    binding: 5,\n                    resource: { buffer: this.colorRotateUnifrom }\n                },\n                {\n                    binding: 6,\n                    resource: { buffer: this.lightDirectionUniform }\n                }\n            ]\n        });\n\n        const vertexLayout: GPUVertexBufferLayout = {\n            arrayStride: 8 * 4,\n            attributes: [\n                { format: \"float32x3\", shaderLocation: 0, offset: 0 },\n                { format: \"float32x3\", shaderLocation: 1, offset: 3 * 4 },\n                { format: \"float32x2\", shaderLocation: 2, offset: 6 * 4 }\n            ]\n        };\n        this.objectRenderPipeline = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout]\n            }),\n            vertex: {\n                module: shaderModule,\n                entryPoint: \"vertex_main\",\n                buffers: [vertexLayout]\n            },\n            fragment: {\n                module: shaderModule,\n                entryPoint: \"fragment_main\",\n                targets: [{ format: Renderer.COLOR_FORMAT }]\n            },\n            depthStencil: {\n                format: Renderer.DEPTH_FORMAT,\n                depthWriteEnabled: true,\n                depthCompare: \"less\"\n            },\n            primitive: {\n                topology: \"triangle-list\",\n                cullMode: \"back\",\n                frontFace: \"cw\"\n            },\n            multisample: {\n                count: Renderer.SAMPLE_COUNT\n            }\n        });\n        this.backgroundRenderPipeline = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout]\n            }),\n            vertex: {\n                module: shaderModule,\n                entryPoint: \"background_vertex_main\",\n                buffers: [vertexLayout]\n            },\n            fragment: {\n                module: shaderModule,\n                entryPoint: \"background_fragment_main\",\n                targets: [{ format: Renderer.COLOR_FORMAT }]\n            },\n            depthStencil: {\n                format: Renderer.DEPTH_FORMAT,\n                depthWriteEnabled: true,\n                depthCompare: \"less-equal\"\n            },\n            primitive: {\n                topology: \"triangle-list\",\n                cullMode: \"back\",\n                frontFace: \"ccw\"\n            },\n            multisample: {\n                count: Renderer.SAMPLE_COUNT\n            }\n        });\n    }\n\n\n    private commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n\n    public renderStart() {\n        (<GPURenderPassColorAttachment[]>this.renderPassDescriptor.colorAttachments)[0].resolveTarget = this.canvasContext.getCurrentTexture().createView();\n        this.commandEncoder = this.device.createCommandEncoder();\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(this.renderPassDescriptor);\n        this.renderPassEncoder.setBindGroup(0, this.gpuBindGroup);\n    }\n\n    public setObjectShader() {\n        this.renderPassEncoder.setPipeline(this.objectRenderPipeline);\n    }\n\n    public renderLittleSphere() {\n        this.renderPassEncoder.setVertexBuffer(0, this.sphereVertexBuffer);\n        this.renderPassEncoder.setIndexBuffer(this.sphereIndexBuffer, \"uint16\");\n        this.renderPassEncoder.drawIndexed(Mesh.sphere.indices.length, 1);\n    }\n\n    public renderSphereCubes() {\n        this.renderPassEncoder.setVertexBuffer(0, this.cubeVertexBuffer);\n        this.renderPassEncoder.setIndexBuffer(this.cubeIndexBuffer, \"uint16\");\n        this.renderPassEncoder.drawIndexed(Mesh.cube.indices.length, Mesh.sphere.vertixCount, 0, 0, 1);\n    }\n\n    public renderDigits(modelsOfDigits: GPUAllowSharedBufferSource) {\n        this.device.queue.writeBuffer(this.modelMatrices, (1 + Mesh.sphere.vertixCount) * 16 * 4, modelsOfDigits);\n\n        this.renderPassEncoder.setVertexBuffer(0, this.cubeVertexBuffer);\n        this.renderPassEncoder.setIndexBuffer(this.cubeIndexBuffer, \"uint16\");\n        this.renderPassEncoder.drawIndexed(Mesh.cube.indices.length, modelsOfDigits.byteLength / (16 * 4), 0, 0, 1 + Mesh.sphere.vertixCount);\n    }\n\n    public setBackgroundShader() {\n        this.renderPassEncoder.setPipeline(this.backgroundRenderPipeline);\n    }\n\n    public renderBeckgound() {\n        this.renderPassEncoder.setVertexBuffer(0, this.sphereVertexBuffer);\n        this.renderPassEncoder.setIndexBuffer(this.sphereIndexBuffer, \"uint16\");\n        this.renderPassEncoder.drawIndexed(Mesh.sphere.indices.length, 1);\n    }\n\n    public renderEnd() {\n        this.renderPassEncoder.end();\n        this.device.queue.submit([this.commandEncoder.finish()]);\n    }\n\n\n\n    public set view(view: Mat4) { this.device.queue.writeBuffer(this.transformationUniform, 0 * 64, <GPUAllowSharedBufferSource>view); }\n\n    public set projection(projection: Mat4) { this.device.queue.writeBuffer(this.transformationUniform, 1 * 64, <GPUAllowSharedBufferSource>projection); }\n\n    public set brightness(brightness: number) { this.device.queue.writeBuffer(this.brightnessUniform, 0, new Float32Array([brightness])); }\n\n    public set colorRotate(colorRotate: number) { this.device.queue.writeBuffer(this.colorRotateUnifrom, 0, new Float32Array([colorRotate])); }\n\n    public set lightDirection(lightDirection: Vec3) { this.device.queue.writeBuffer(this.lightDirectionUniform, 0, <GPUAllowSharedBufferSource>lightDirection); }\n\n\n\n    public renewRenderTextures() {\n        this.renderPassDescriptor.depthStencilAttachment!.view = this.createDepthStencilView();\n        (<GPURenderPassColorAttachment[]>this.renderPassDescriptor.colorAttachments)[0].view = this.createMultisampleTexture();\n    }\n\n    private createDepthStencilView(): GPUTextureView {\n        return this.device.createTexture({\n            size: {\n                width: this.htmlCanvas.width,\n                height: this.htmlCanvas.height,\n                depthOrArrayLayers: 1\n            },\n            format: Renderer.DEPTH_FORMAT,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n            sampleCount: Renderer.SAMPLE_COUNT\n        }).createView();\n    }\n\n    private createMultisampleTexture(): GPUTextureView {\n        return this.device.createTexture({\n            size: {\n                width: this.htmlCanvas.width,\n                height: this.htmlCanvas.height,\n                depthOrArrayLayers: 1,\n            },\n            format: Renderer.COLOR_FORMAT,\n            // @ts-ignore\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.SAMPLED,\n            sampleCount: Renderer.SAMPLE_COUNT\n        }).createView();\n    }\n}\n","/* wgpu-matrix@3.4.0, license MIT */\nfunction wrapConstructor(OriginalConstructor, modifier) {\n    return class extends OriginalConstructor {\n        constructor(...args) {\n            super(...args);\n            modifier(this);\n        }\n    }; // Type assertion is necessary here\n}\nconst ZeroArray = wrapConstructor((Array), a => a.fill(0));\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = {\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    degToRad: degToRad,\n    euclideanModulo: euclideanModulo,\n    inverseLerp: inverseLerp,\n    lerp: lerp,\n    radToDeg: radToDeg,\n    setEpsilon: setEpsilon\n};\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Vec3\n */\nfunction getAPIImpl$5(Ctor) {\n    /**\n     * Creates a Vec2; may be called with x, y, z to set initial values.\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Vec2's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const v = vec2.clone(someJSArray);\n     * ```\n     *\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @returns the created vector\n     */\n    function create(x = 0, y = 0) {\n        const newDst = new Ctor(2);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Vec2\n     * Also see {@link vec2.create} and {@link vec2.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = x;\n        newDst[1] = y;\n        return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.ceil(v[0]);\n        newDst[1] = Math.ceil(v[1]);\n        return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.floor(v[0]);\n        newDst[1] = Math.floor(v[1]);\n        return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.round(v[0]);\n        newDst[1] = Math.round(v[1]);\n        return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v, min = 0, max = 1, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.min(max, Math.max(min, v[0]));\n        newDst[1] = Math.min(max, Math.max(min, v[1]));\n        return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + b[0] * scale;\n        newDst[1] = a[1] + b[1] * scale;\n        return newDst;\n    }\n    /**\n     * Returns the angle in radians between two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns The angle in radians between the 2 vectors.\n     */\n    function angle(a, b) {\n        const ax = a[0];\n        const ay = a[1];\n        const bx = b[0];\n        const by = b[1];\n        const mag1 = Math.sqrt(ax * ax + ay * ay);\n        const mag2 = Math.sqrt(bx * bx + by * by);\n        const mag = mag1 * mag2;\n        const cosine = mag && dot(a, b) / mag;\n        return Math.acos(cosine);\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n        newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n        return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.max(a[0], b[0]);\n        newDst[1] = Math.max(a[1], b[1]);\n        return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.min(a[0], b[0]);\n        newDst[1] = Math.min(a[1], b[1]);\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = 1 / v[0];\n        newDst[1] = 1 / v[1];\n        return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    const invert = inverse;\n    /**\n     * Computes the cross product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of a cross b.\n     */\n    function cross(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const z = a[0] * b[1] - a[1] * b[0];\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = z;\n        return newDst;\n    }\n    /**\n     * Computes the dot product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1];\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        return Math.sqrt(v0 * v0 + v1 * v1);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        return v0 * v0 + v1 * v1;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    const dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        return dx * dx + dy * dy;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    const distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const v0 = v[0];\n        const v1 = v[1];\n        const len = Math.sqrt(v0 * v0 + v1 * v1);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n        }\n        return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = -v[0];\n        newDst[1] = -v[1];\n        return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec2.clone})\n     * Also see {@link vec2.create} and {@link vec2.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = v[0];\n        newDst[1] = v[1];\n        return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec2.copy})\n     * Also see {@link vec2.create} and {@link vec2.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    const clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] * b[0];\n        newDst[1] = a[1] * b[1];\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] / b[0];\n        newDst[1] = a[1] / b[1];\n        return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    const div = divide;\n    /**\n     * Creates a random unit vector * scale\n     * @param scale - Default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The random vector.\n     */\n    function random(scale = 1, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const angle = Math.random() * 2 * Math.PI;\n        newDst[0] = Math.cos(angle) * scale;\n        newDst[1] = Math.sin(angle) * scale;\n        return newDst;\n    }\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        return newDst;\n    }\n    /**\n     * Transform Vec2 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional Vec2 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const x = v[0];\n        const y = v[1];\n        newDst[0] = x * m[0] + y * m[4] + m[12];\n        newDst[1] = x * m[1] + y * m[5] + m[13];\n        return newDst;\n    }\n    /**\n     * Transform Vec2 by 3x3 matrix\n     *\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional Vec2 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat3(v, m, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const x = v[0];\n        const y = v[1];\n        newDst[0] = m[0] * x + m[4] * y + m[8];\n        newDst[1] = m[1] * x + m[5] * y + m[9];\n        return newDst;\n    }\n    /**\n     * Rotate a 2D vector\n     *\n     * @param a The vec2 point to rotate\n     * @param b The origin of the rotation\n     * @param rad The angle of rotation in radians\n     * @returns the rotated vector\n     */\n    function rotate(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        // Translate point to the origin\n        const p0 = a[0] - b[0];\n        const p1 = a[1] - b[1];\n        const sinC = Math.sin(rad);\n        const cosC = Math.cos(rad);\n        //perform rotation and translate to correct position\n        newDst[0] = p0 * cosC - p1 * sinC + b[0];\n        newDst[1] = p0 * sinC + p1 * cosC + b[1];\n        return newDst;\n    }\n    /**\n     * Treat a 2D vector as a direction and set it's length\n     *\n     * @param a The vec2 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        normalize(a, newDst);\n        return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec2 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        if (length(a) > maxLen) {\n            return setLength(a, maxLen, newDst);\n        }\n        return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        return lerp(a, b, 0.5, newDst);\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        ceil,\n        floor,\n        round,\n        clamp,\n        add,\n        addScaled,\n        angle,\n        subtract,\n        sub,\n        equalsApproximately,\n        equals,\n        lerp,\n        lerpV,\n        max,\n        min,\n        mulScalar,\n        scale,\n        divScalar,\n        inverse,\n        invert,\n        cross,\n        dot,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        distance,\n        dist,\n        distanceSq,\n        distSq,\n        normalize,\n        negate,\n        copy,\n        clone,\n        multiply,\n        mul,\n        divide,\n        div,\n        random,\n        zero,\n        transformMat4,\n        transformMat3,\n        rotate,\n        setLength,\n        truncate,\n        midpoint,\n    };\n}\nconst cache$5 = new Map();\nfunction getAPI$5(Ctor) {\n    let api = cache$5.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$5(Ctor);\n        cache$5.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Vec3\n * */\nfunction getAPIImpl$4(Ctor) {\n    /**\n     * Creates a vec3; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @returns the created vector\n     */\n    function create(x, y, z) {\n        const newDst = new Ctor(3);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n                if (z !== undefined) {\n                    newDst[2] = z;\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Vec3\n     * Also see {@link vec3.create} and {@link vec3.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = x;\n        newDst[1] = y;\n        newDst[2] = z;\n        return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.ceil(v[0]);\n        newDst[1] = Math.ceil(v[1]);\n        newDst[2] = Math.ceil(v[2]);\n        return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.floor(v[0]);\n        newDst[1] = Math.floor(v[1]);\n        newDst[2] = Math.floor(v[2]);\n        return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.round(v[0]);\n        newDst[1] = Math.round(v[1]);\n        newDst[2] = Math.round(v[2]);\n        return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v, min = 0, max = 1, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.min(max, Math.max(min, v[0]));\n        newDst[1] = Math.min(max, Math.max(min, v[1]));\n        newDst[2] = Math.min(max, Math.max(min, v[2]));\n        return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + b[0] * scale;\n        newDst[1] = a[1] + b[1] * scale;\n        newDst[2] = a[2] + b[2] * scale;\n        return newDst;\n    }\n    /**\n     * Returns the angle in radians between two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns The angle in radians between the 2 vectors.\n     */\n    function angle(a, b) {\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const bx = b[0];\n        const by = b[1];\n        const bz = b[2];\n        const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n        const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n        const mag = mag1 * mag2;\n        const cosine = mag && dot(a, b) / mag;\n        return Math.acos(cosine);\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        newDst[2] = a[2] - b[2];\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        newDst[2] = a[2] + t * (b[2] - a[2]);\n        return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n        newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n        newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n        return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.max(a[0], b[0]);\n        newDst[1] = Math.max(a[1], b[1]);\n        newDst[2] = Math.max(a[2], b[2]);\n        return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.min(a[0], b[0]);\n        newDst[1] = Math.min(a[1], b[1]);\n        newDst[2] = Math.min(a[2], b[2]);\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        newDst[2] = v[2] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        newDst[2] = v[2] / k;\n        return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = 1 / v[0];\n        newDst[1] = 1 / v[1];\n        newDst[2] = 1 / v[2];\n        return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    const invert = inverse;\n    /**\n     * Computes the cross product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of a cross b.\n     */\n    function cross(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const t1 = a[2] * b[0] - a[0] * b[2];\n        const t2 = a[0] * b[1] - a[1] * b[0];\n        newDst[0] = a[1] * b[2] - a[2] * b[1];\n        newDst[1] = t1;\n        newDst[2] = t2;\n        return newDst;\n    }\n    /**\n     * Computes the dot product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return v0 * v0 + v1 * v1 + v2 * v2;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    const dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        return dx * dx + dy * dy + dz * dz;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    const distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n            newDst[2] = v2 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n        }\n        return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = -v[0];\n        newDst[1] = -v[1];\n        newDst[2] = -v[2];\n        return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec3.clone})\n     * Also see {@link vec3.create} and {@link vec3.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = v[0];\n        newDst[1] = v[1];\n        newDst[2] = v[2];\n        return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec3.copy})\n     * Also see {@link vec3.create} and {@link vec3.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    const clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] * b[0];\n        newDst[1] = a[1] * b[1];\n        newDst[2] = a[2] * b[2];\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] / b[0];\n        newDst[1] = a[1] / b[1];\n        newDst[2] = a[2] / b[2];\n        return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    const div = divide;\n    /**\n     * Creates a random vector\n     * @param scale - Default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The random vector.\n     */\n    function random(scale = 1, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const angle = Math.random() * 2 * Math.PI;\n        const z = Math.random() * 2 - 1;\n        const zScale = Math.sqrt(1 - z * z) * scale;\n        newDst[0] = Math.cos(angle) * zScale;\n        newDst[1] = Math.sin(angle) * zScale;\n        newDst[2] = z * scale;\n        return newDst;\n    }\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        return newDst;\n    }\n    /**\n     * transform vec3 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n        newDst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n        newDst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n        newDst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n        return newDst;\n    }\n    /**\n     * Transform vec3 by upper 3x3 matrix inside 4x4 matrix.\n     * @param v - The direction.\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns The transformed vector.\n     */\n    function transformMat4Upper3x3(v, m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        newDst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n        newDst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n        newDst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n        return newDst;\n    }\n    /**\n     * Transforms vec3 by 3x3 matrix\n     *\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat3(v, m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        newDst[0] = x * m[0] + y * m[4] + z * m[8];\n        newDst[1] = x * m[1] + y * m[5] + z * m[9];\n        newDst[2] = x * m[2] + y * m[6] + z * m[10];\n        return newDst;\n    }\n    /**\n     * Transforms vec3 by Quaternion\n     * @param v - the vector to transform\n     * @param q - the quaternion to transform by\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed\n     */\n    function transformQuat(v, q, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const w2 = q[3] * 2;\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        const uvX = qy * z - qz * y;\n        const uvY = qz * x - qx * z;\n        const uvZ = qx * y - qy * x;\n        newDst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;\n        newDst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;\n        newDst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;\n        return newDst;\n    }\n    /**\n     * Returns the translation component of a 4-by-4 matrix as a vector with 3\n     * entries.\n     * @param m - The matrix.\n     * @param dst - vector to hold result. If not passed a new one is created.\n     * @returns The translation component of m.\n     */\n    function getTranslation(m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = m[12];\n        newDst[1] = m[13];\n        newDst[2] = m[14];\n        return newDst;\n    }\n    /**\n     * Returns an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y, 2 = z;\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const off = axis * 4;\n        newDst[0] = m[off + 0];\n        newDst[1] = m[off + 1];\n        newDst[2] = m[off + 2];\n        return newDst;\n    }\n    /**\n     * Returns the scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function getScaling(m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const xx = m[0];\n        const xy = m[1];\n        const xz = m[2];\n        const yx = m[4];\n        const yy = m[5];\n        const yz = m[6];\n        const zx = m[8];\n        const zy = m[9];\n        const zz = m[10];\n        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n        return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns the rotated vector\n     */\n    function rotateX(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const p = [];\n        const r = [];\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n        r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n        //translate to correct position\n        newDst[0] = r[0] + b[0];\n        newDst[1] = r[1] + b[1];\n        newDst[2] = r[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns the rotated vector\n     */\n    function rotateY(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const p = [];\n        const r = [];\n        // translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n        // perform rotation\n        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n        // translate to correct position\n        newDst[0] = r[0] + b[0];\n        newDst[1] = r[1] + b[1];\n        newDst[2] = r[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns {vec3} out\n     */\n    function rotateZ(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const p = [];\n        const r = [];\n        // translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n        // perform rotation\n        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n        r[2] = p[2];\n        // translate to correct position\n        newDst[0] = r[0] + b[0];\n        newDst[1] = r[1] + b[1];\n        newDst[2] = r[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Treat a 3D vector as a direction and set it's length\n     *\n     * @param a The vec3 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        normalize(a, newDst);\n        return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec3 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        if (length(a) > maxLen) {\n            return setLength(a, maxLen, newDst);\n        }\n        return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        return lerp(a, b, 0.5, newDst);\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        ceil,\n        floor,\n        round,\n        clamp,\n        add,\n        addScaled,\n        angle,\n        subtract,\n        sub,\n        equalsApproximately,\n        equals,\n        lerp,\n        lerpV,\n        max,\n        min,\n        mulScalar,\n        scale,\n        divScalar,\n        inverse,\n        invert,\n        cross,\n        dot,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        distance,\n        dist,\n        distanceSq,\n        distSq,\n        normalize,\n        negate,\n        copy,\n        clone,\n        multiply,\n        mul,\n        divide,\n        div,\n        random,\n        zero,\n        transformMat4,\n        transformMat4Upper3x3,\n        transformMat3,\n        transformQuat,\n        getTranslation,\n        getAxis,\n        getScaling,\n        rotateX,\n        rotateY,\n        rotateZ,\n        setLength,\n        truncate,\n        midpoint,\n    };\n}\nconst cache$4 = new Map();\nfunction getAPI$4(Ctor) {\n    let api = cache$4.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$4(Ctor);\n        cache$4.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates a typed API for Mat3\n * */\nfunction getAPIImpl$3(Ctor) {\n    const vec2 = getAPI$5(Ctor);\n    const vec3 = getAPI$4(Ctor);\n    /**\n     * Create a Mat3 from values\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Mat3's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const m = mat3.clone(someJSArray);\n     * ```\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @returns matrix created from values.\n     */\n    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n        const newDst = new Ctor(12);\n        // to make the array homogenous\n        newDst[3] = 0;\n        newDst[7] = 0;\n        newDst[11] = 0;\n        if (v0 !== undefined) {\n            newDst[0] = v0;\n            if (v1 !== undefined) {\n                newDst[1] = v1;\n                if (v2 !== undefined) {\n                    newDst[2] = v2;\n                    if (v3 !== undefined) {\n                        newDst[4] = v3;\n                        if (v4 !== undefined) {\n                            newDst[5] = v4;\n                            if (v5 !== undefined) {\n                                newDst[6] = v5;\n                                if (v6 !== undefined) {\n                                    newDst[8] = v6;\n                                    if (v7 !== undefined) {\n                                        newDst[9] = v7;\n                                        if (v8 !== undefined) {\n                                            newDst[10] = v8;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Sets the values of a Mat3\n     * Also see {@link mat3.create} and {@link mat3.copy}\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 set from values.\n     */\n    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = v0;\n        newDst[1] = v1;\n        newDst[2] = v2;\n        newDst[3] = 0;\n        newDst[4] = v3;\n        newDst[5] = v4;\n        newDst[6] = v5;\n        newDst[7] = 0;\n        newDst[8] = v6;\n        newDst[9] = v7;\n        newDst[10] = v8;\n        newDst[11] = 0;\n        return newDst;\n    }\n    /**\n     * Creates a Mat3 from the upper left 3x3 part of a Mat4\n     * @param m4 - source matrix\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 made from m4\n     */\n    function fromMat4(m4, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = m4[0];\n        newDst[1] = m4[1];\n        newDst[2] = m4[2];\n        newDst[3] = 0;\n        newDst[4] = m4[4];\n        newDst[5] = m4[5];\n        newDst[6] = m4[6];\n        newDst[7] = 0;\n        newDst[8] = m4[8];\n        newDst[9] = m4[9];\n        newDst[10] = m4[10];\n        newDst[11] = 0;\n        return newDst;\n    }\n    /**\n     * Creates a Mat3 rotation matrix from a quaternion\n     * @param q - quaternion to create matrix from\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 made from q\n     */\n    function fromQuat(q, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const yx = y * x2;\n        const yy = y * y2;\n        const zx = z * x2;\n        const zy = z * y2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        newDst[0] = 1 - yy - zz;\n        newDst[1] = yx + wz;\n        newDst[2] = zx - wy;\n        newDst[3] = 0;\n        newDst[4] = yx - wz;\n        newDst[5] = 1 - xx - zz;\n        newDst[6] = zy + wx;\n        newDst[7] = 0;\n        newDst[8] = zx + wy;\n        newDst[9] = zy - wx;\n        newDst[10] = 1 - xx - yy;\n        newDst[11] = 0;\n        return newDst;\n    }\n    /**\n     * Negates a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns -m.\n     */\n    function negate(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = -m[0];\n        newDst[1] = -m[1];\n        newDst[2] = -m[2];\n        newDst[4] = -m[4];\n        newDst[5] = -m[5];\n        newDst[6] = -m[6];\n        newDst[8] = -m[8];\n        newDst[9] = -m[9];\n        newDst[10] = -m[10];\n        return newDst;\n    }\n    /**\n     * multiply a matrix by a scalar matrix.\n     * @param m - The matrix.\n     * @param s - the scalar\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns m * s.\n     */\n    function multiplyScalar(m, s, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = m[0] * s;\n        newDst[1] = m[1] * s;\n        newDst[2] = m[2] * s;\n        newDst[4] = m[4] * s;\n        newDst[5] = m[5] * s;\n        newDst[6] = m[6] * s;\n        newDst[8] = m[8] * s;\n        newDst[9] = m[9] * s;\n        newDst[10] = m[10] * s;\n        return newDst;\n    }\n    /**\n     * multiply a matrix by a scalar matrix.\n     * @param m - The matrix.\n     * @param s - the scalar\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns m * s.\n     */\n    const mulScalar = multiplyScalar;\n    /**\n     * add 2 matrices.\n     * @param a - matrix 1.\n     * @param b - matrix 2.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns a + b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        newDst[4] = a[4] + b[4];\n        newDst[5] = a[5] + b[5];\n        newDst[6] = a[6] + b[6];\n        newDst[8] = a[8] + b[8];\n        newDst[9] = a[9] + b[9];\n        newDst[10] = a[10] + b[10];\n        return newDst;\n    }\n    /**\n     * Copies a matrix. (same as {@link mat3.clone})\n     * Also see {@link mat3.create} and {@link mat3.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    function copy(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = m[0];\n        newDst[1] = m[1];\n        newDst[2] = m[2];\n        newDst[4] = m[4];\n        newDst[5] = m[5];\n        newDst[6] = m[6];\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n        return newDst;\n    }\n    /**\n     * Copies a matrix (same as {@link mat3.copy})\n     * Also see {@link mat3.create} and {@link mat3.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    const clone = copy;\n    /**\n     * Check if 2 matrices are approximately equal\n     * @param a Operand matrix.\n     * @param b Operand matrix.\n     * @returns true if matrices are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[4] - b[4]) < EPSILON &&\n            Math.abs(a[5] - b[5]) < EPSILON &&\n            Math.abs(a[6] - b[6]) < EPSILON &&\n            Math.abs(a[8] - b[8]) < EPSILON &&\n            Math.abs(a[9] - b[9]) < EPSILON &&\n            Math.abs(a[10] - b[10]) < EPSILON;\n    }\n    /**\n     * Check if 2 matrices are exactly equal\n     * @param a Operand matrix.\n     * @param b Operand matrix.\n     * @returns true if matrices are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] &&\n            a[1] === b[1] &&\n            a[2] === b[2] &&\n            a[4] === b[4] &&\n            a[5] === b[5] &&\n            a[6] === b[6] &&\n            a[8] === b[8] &&\n            a[9] === b[9] &&\n            a[10] === b[10];\n    }\n    /**\n     * Creates a 3-by-3 identity matrix.\n     *\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A 3-by-3 identity matrix.\n     */\n    function identity(dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Takes the transpose of a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The transpose of m.\n     */\n    function transpose(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        if (newDst === m) {\n            let t;\n            // 0 1 2\n            // 4 5 6\n            // 8 9 10\n            t = m[1];\n            m[1] = m[4];\n            m[4] = t;\n            t = m[2];\n            m[2] = m[8];\n            m[8] = t;\n            t = m[6];\n            m[6] = m[9];\n            m[9] = t;\n            return newDst;\n        }\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        newDst[0] = m00;\n        newDst[1] = m10;\n        newDst[2] = m20;\n        newDst[4] = m01;\n        newDst[5] = m11;\n        newDst[6] = m21;\n        newDst[8] = m02;\n        newDst[9] = m12;\n        newDst[10] = m22;\n        return newDst;\n    }\n    /**\n     * Computes the inverse of a 3-by-3 matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    function inverse(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const b01 = m22 * m11 - m12 * m21;\n        const b11 = -m22 * m10 + m12 * m20;\n        const b21 = m21 * m10 - m11 * m20;\n        const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);\n        newDst[0] = b01 * invDet;\n        newDst[1] = (-m22 * m01 + m02 * m21) * invDet;\n        newDst[2] = (m12 * m01 - m02 * m11) * invDet;\n        newDst[4] = b11 * invDet;\n        newDst[5] = (m22 * m00 - m02 * m20) * invDet;\n        newDst[6] = (-m12 * m00 + m02 * m10) * invDet;\n        newDst[8] = b21 * invDet;\n        newDst[9] = (-m21 * m00 + m01 * m20) * invDet;\n        newDst[10] = (m11 * m00 - m01 * m10) * invDet;\n        return newDst;\n    }\n    /**\n     * Compute the determinant of a matrix\n     * @param m - the matrix\n     * @returns the determinant\n     */\n    function determinant(m) {\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        return m00 * (m11 * m22 - m21 * m12) -\n            m10 * (m01 * m22 - m21 * m02) +\n            m20 * (m01 * m12 - m11 * m02);\n    }\n    /**\n     * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    const invert = inverse;\n    /**\n     * Multiplies two 3-by-3 matrices with a on the left and b on the right\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a10 = a[4 + 0];\n        const a11 = a[4 + 1];\n        const a12 = a[4 + 2];\n        const a20 = a[8 + 0];\n        const a21 = a[8 + 1];\n        const a22 = a[8 + 2];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b10 = b[4 + 0];\n        const b11 = b[4 + 1];\n        const b12 = b[4 + 2];\n        const b20 = b[8 + 0];\n        const b21 = b[8 + 1];\n        const b22 = b[8 + 2];\n        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n        return newDst;\n    }\n    /**\n     * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Sets the translation component of a 3-by-3 matrix to the given\n     * vector.\n     * @param a - The matrix.\n     * @param v - The vector.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix with translation set.\n     */\n    function setTranslation(a, v, dst) {\n        const newDst = (dst ?? identity());\n        if (a !== newDst) {\n            newDst[0] = a[0];\n            newDst[1] = a[1];\n            newDst[2] = a[2];\n            newDst[4] = a[4];\n            newDst[5] = a[5];\n            newDst[6] = a[6];\n        }\n        newDst[8] = v[0];\n        newDst[9] = v[1];\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Returns the translation component of a 3-by-3 matrix as a vector with 3\n     * entries.\n     * @param m - The matrix.\n     * @param dst - vector to hold result. If not passed a new one is created.\n     * @returns The translation component of m.\n     */\n    function getTranslation(m, dst) {\n        const newDst = (dst ?? vec2.create());\n        newDst[0] = m[8];\n        newDst[1] = m[9];\n        return newDst;\n    }\n    /**\n     * Returns an axis of a 3x3 matrix as a vector with 2 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y,\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n        const newDst = (dst ?? vec2.create());\n        const off = axis * 4;\n        newDst[0] = m[off + 0];\n        newDst[1] = m[off + 1];\n        return newDst;\n    }\n    /**\n     * Sets an axis of a 3x3 matrix as a vector with 2 entries\n     * @param m - The matrix.\n     * @param v - the axis vector\n     * @param axis - The axis  0 = x, 1 = y;\n     * @param dst - The matrix to set. If not passed a new one is created.\n     * @returns The matrix with axis set.\n     */\n    function setAxis(m, v, axis, dst) {\n        const newDst = (dst === m ? m : copy(m, dst));\n        const off = axis * 4;\n        newDst[off + 0] = v[0];\n        newDst[off + 1] = v[1];\n        return newDst;\n    }\n    /**\n     * Returns the \"2d\" scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function getScaling(m, dst) {\n        const newDst = (dst ?? vec2.create());\n        const xx = m[0];\n        const xy = m[1];\n        const yx = m[4];\n        const yy = m[5];\n        newDst[0] = Math.sqrt(xx * xx + xy * xy);\n        newDst[1] = Math.sqrt(yx * yx + yy * yy);\n        return newDst;\n    }\n    /**\n     * Returns the \"3d\" scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function get3DScaling(m, dst) {\n        const newDst = (dst ?? vec3.create());\n        const xx = m[0];\n        const xy = m[1];\n        const xz = m[2];\n        const yx = m[4];\n        const yy = m[5];\n        const yz = m[6];\n        const zx = m[8];\n        const zy = m[9];\n        const zz = m[10];\n        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which translates by the given vector v.\n     * @param v - The vector by which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translation matrix.\n     */\n    function translation(v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[8] = v[0];\n        newDst[9] = v[1];\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Translates the given 3-by-3 matrix by the given vector v.\n     * @param m - The matrix.\n     * @param v - The vector by which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translated matrix.\n     */\n    function translate(m, v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const v0 = v[0];\n        const v1 = v[1];\n        const m00 = m[0];\n        const m01 = m[1];\n        const m02 = m[2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        if (m !== newDst) {\n            newDst[0] = m00;\n            newDst[1] = m01;\n            newDst[2] = m02;\n            newDst[4] = m10;\n            newDst[5] = m11;\n            newDst[6] = m12;\n        }\n        newDst[8] = m00 * v0 + m10 * v1 + m20;\n        newDst[9] = m01 * v0 + m11 * v1 + m21;\n        newDst[10] = m02 * v0 + m12 * v1 + m22;\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates  by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotation(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c;\n        newDst[1] = s;\n        newDst[2] = 0;\n        newDst[4] = -s;\n        newDst[5] = c;\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 3-by-3 matrix  by the given angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotate(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c * m00 + s * m10;\n        newDst[1] = c * m01 + s * m11;\n        newDst[2] = c * m02 + s * m12;\n        newDst[4] = c * m10 - s * m00;\n        newDst[5] = c * m11 - s * m01;\n        newDst[6] = c * m12 - s * m02;\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates around the x-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationX(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = c;\n        newDst[6] = s;\n        newDst[8] = 0;\n        newDst[9] = -s;\n        newDst[10] = c;\n        return newDst;\n    }\n    /**\n     * Rotates the given 3-by-3 matrix around the x-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateX(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const m10 = m[4];\n        const m11 = m[5];\n        const m12 = m[6];\n        const m20 = m[8];\n        const m21 = m[9];\n        const m22 = m[10];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[4] = c * m10 + s * m20;\n        newDst[5] = c * m11 + s * m21;\n        newDst[6] = c * m12 + s * m22;\n        newDst[8] = c * m20 - s * m10;\n        newDst[9] = c * m21 - s * m11;\n        newDst[10] = c * m22 - s * m12;\n        if (m !== newDst) {\n            newDst[0] = m[0];\n            newDst[1] = m[1];\n            newDst[2] = m[2];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates around the y-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationY(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c;\n        newDst[1] = 0;\n        newDst[2] = -s;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[8] = s;\n        newDst[9] = 0;\n        newDst[10] = c;\n        return newDst;\n    }\n    /**\n     * Rotates the given 3-by-3 matrix around the y-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateY(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c * m00 - s * m20;\n        newDst[1] = c * m01 - s * m21;\n        newDst[2] = c * m02 - s * m22;\n        newDst[8] = c * m20 + s * m00;\n        newDst[9] = c * m21 + s * m01;\n        newDst[10] = c * m22 + s * m02;\n        if (m !== newDst) {\n            newDst[4] = m[4];\n            newDst[5] = m[5];\n            newDst[6] = m[6];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates around the z-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    const rotationZ = rotation;\n    /**\n     * Rotates the given 3-by-3 matrix around the z-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    const rotateZ = rotate;\n    /**\n     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has two\n     * entries.\n     * @param v - A vector of\n     *     2 entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling(v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = v[0];\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = v[1];\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * two entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of 2 entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale(m, v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const v0 = v[0];\n        const v1 = v[1];\n        newDst[0] = v0 * m[0 * 4 + 0];\n        newDst[1] = v0 * m[0 * 4 + 1];\n        newDst[2] = v0 * m[0 * 4 + 2];\n        newDst[4] = v1 * m[1 * 4 + 0];\n        newDst[5] = v1 * m[1 * 4 + 1];\n        newDst[6] = v1 * m[1 * 4 + 2];\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has three\n     * entries.\n     * @param v - A vector of\n     *     3 entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling3D(v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = v[0];\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = v[1];\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = v[2];\n        return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * three entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of 3 entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale3D(m, v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        newDst[0] = v0 * m[0 * 4 + 0];\n        newDst[1] = v0 * m[0 * 4 + 1];\n        newDst[2] = v0 * m[0 * 4 + 2];\n        newDst[4] = v1 * m[1 * 4 + 0];\n        newDst[5] = v1 * m[1 * 4 + 1];\n        newDst[6] = v1 * m[1 * 4 + 2];\n        newDst[8] = v2 * m[2 * 4 + 0];\n        newDst[9] = v2 * m[2 * 4 + 1];\n        newDst[10] = v2 * m[2 * 4 + 2];\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales uniformly in the X and Y dimensions\n     * @param s - Amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling(s, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = s;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = s;\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in the X and Y dimension by an amount\n     * given.\n     * @param m - The matrix to be modified.\n     * @param s - Amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale(m, s, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = s * m[0 * 4 + 0];\n        newDst[1] = s * m[0 * 4 + 1];\n        newDst[2] = s * m[0 * 4 + 2];\n        newDst[4] = s * m[1 * 4 + 0];\n        newDst[5] = s * m[1 * 4 + 1];\n        newDst[6] = s * m[1 * 4 + 2];\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales uniformly in each dimension\n     * @param s - Amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling3D(s, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = s;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = s;\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = s;\n        return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given.\n     * @param m - The matrix to be modified.\n     * @param s - Amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale3D(m, s, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = s * m[0 * 4 + 0];\n        newDst[1] = s * m[0 * 4 + 1];\n        newDst[2] = s * m[0 * 4 + 2];\n        newDst[4] = s * m[1 * 4 + 0];\n        newDst[5] = s * m[1 * 4 + 1];\n        newDst[6] = s * m[1 * 4 + 2];\n        newDst[8] = s * m[2 * 4 + 0];\n        newDst[9] = s * m[2 * 4 + 1];\n        newDst[10] = s * m[2 * 4 + 2];\n        return newDst;\n    }\n    return {\n        add,\n        clone,\n        copy,\n        create,\n        determinant,\n        equals,\n        equalsApproximately,\n        fromMat4,\n        fromQuat,\n        get3DScaling,\n        getAxis,\n        getScaling,\n        getTranslation,\n        identity,\n        inverse,\n        invert,\n        mul,\n        mulScalar,\n        multiply,\n        multiplyScalar,\n        negate,\n        rotate,\n        rotateX,\n        rotateY,\n        rotateZ,\n        rotation,\n        rotationX,\n        rotationY,\n        rotationZ,\n        scale,\n        scale3D,\n        scaling,\n        scaling3D,\n        set,\n        setAxis,\n        setTranslation,\n        translate,\n        translation,\n        transpose,\n        uniformScale,\n        uniformScale3D,\n        uniformScaling,\n        uniformScaling3D,\n    };\n}\nconst cache$3 = new Map();\nfunction getAPI$3(Ctor) {\n    let api = cache$3.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$3(Ctor);\n        cache$3.set(Ctor, api);\n    }\n    return api;\n}\n\n/**\n * Generates a typed API for Mat4\n * */\nfunction getAPIImpl$2(Ctor) {\n    const vec3 = getAPI$4(Ctor);\n    /**\n     * 4x4 Matrix math math functions.\n     *\n     * Almost all functions take an optional `newDst` argument. If it is not passed in the\n     * functions will create a new matrix. In other words you can do this\n     *\n     *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n     *\n     * or\n     *\n     *     const mat = mat4.create();\n     *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n     *\n     * The first style is often easier but depending on where it's used it generates garbage where\n     * as there is almost never allocation with the second style.\n     *\n     * It is always save to pass any matrix as the destination. So for example\n     *\n     *     const mat = mat4.identity();\n     *     const trans = mat4.translation([1, 2, 3]);\n     *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n     *\n     */\n    /**\n     * Create a Mat4 from values\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Mat4's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const m = mat4.clone(someJSArray);\n     * ```\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param v9 - value for element 9\n     * @param v10 - value for element 10\n     * @param v11 - value for element 11\n     * @param v12 - value for element 12\n     * @param v13 - value for element 13\n     * @param v14 - value for element 14\n     * @param v15 - value for element 15\n     * @returns created from values.\n     */\n    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n        const newDst = new Ctor(16);\n        if (v0 !== undefined) {\n            newDst[0] = v0;\n            if (v1 !== undefined) {\n                newDst[1] = v1;\n                if (v2 !== undefined) {\n                    newDst[2] = v2;\n                    if (v3 !== undefined) {\n                        newDst[3] = v3;\n                        if (v4 !== undefined) {\n                            newDst[4] = v4;\n                            if (v5 !== undefined) {\n                                newDst[5] = v5;\n                                if (v6 !== undefined) {\n                                    newDst[6] = v6;\n                                    if (v7 !== undefined) {\n                                        newDst[7] = v7;\n                                        if (v8 !== undefined) {\n                                            newDst[8] = v8;\n                                            if (v9 !== undefined) {\n                                                newDst[9] = v9;\n                                                if (v10 !== undefined) {\n                                                    newDst[10] = v10;\n                                                    if (v11 !== undefined) {\n                                                        newDst[11] = v11;\n                                                        if (v12 !== undefined) {\n                                                            newDst[12] = v12;\n                                                            if (v13 !== undefined) {\n                                                                newDst[13] = v13;\n                                                                if (v14 !== undefined) {\n                                                                    newDst[14] = v14;\n                                                                    if (v15 !== undefined) {\n                                                                        newDst[15] = v15;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Sets the values of a Mat4\n     * Also see {@link mat4.create} and {@link mat4.copy}\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param v9 - value for element 9\n     * @param v10 - value for element 10\n     * @param v11 - value for element 11\n     * @param v12 - value for element 12\n     * @param v13 - value for element 13\n     * @param v14 - value for element 14\n     * @param v15 - value for element 15\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 created from values.\n     */\n    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = v0;\n        newDst[1] = v1;\n        newDst[2] = v2;\n        newDst[3] = v3;\n        newDst[4] = v4;\n        newDst[5] = v5;\n        newDst[6] = v6;\n        newDst[7] = v7;\n        newDst[8] = v8;\n        newDst[9] = v9;\n        newDst[10] = v10;\n        newDst[11] = v11;\n        newDst[12] = v12;\n        newDst[13] = v13;\n        newDst[14] = v14;\n        newDst[15] = v15;\n        return newDst;\n    }\n    /**\n     * Creates a Mat4 from a Mat3\n     * @param m3 - source matrix\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 made from m3\n     */\n    function fromMat3(m3, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = m3[0];\n        newDst[1] = m3[1];\n        newDst[2] = m3[2];\n        newDst[3] = 0;\n        newDst[4] = m3[4];\n        newDst[5] = m3[5];\n        newDst[6] = m3[6];\n        newDst[7] = 0;\n        newDst[8] = m3[8];\n        newDst[9] = m3[9];\n        newDst[10] = m3[10];\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Creates a Mat4 rotation matrix from a quaternion\n     * @param q - quaternion to create matrix from\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 made from q\n     */\n    function fromQuat(q, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const yx = y * x2;\n        const yy = y * y2;\n        const zx = z * x2;\n        const zy = z * y2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        newDst[0] = 1 - yy - zz;\n        newDst[1] = yx + wz;\n        newDst[2] = zx - wy;\n        newDst[3] = 0;\n        newDst[4] = yx - wz;\n        newDst[5] = 1 - xx - zz;\n        newDst[6] = zy + wx;\n        newDst[7] = 0;\n        newDst[8] = zx + wy;\n        newDst[9] = zy - wx;\n        newDst[10] = 1 - xx - yy;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Negates a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns -m.\n     */\n    function negate(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = -m[0];\n        newDst[1] = -m[1];\n        newDst[2] = -m[2];\n        newDst[3] = -m[3];\n        newDst[4] = -m[4];\n        newDst[5] = -m[5];\n        newDst[6] = -m[6];\n        newDst[7] = -m[7];\n        newDst[8] = -m[8];\n        newDst[9] = -m[9];\n        newDst[10] = -m[10];\n        newDst[11] = -m[11];\n        newDst[12] = -m[12];\n        newDst[13] = -m[13];\n        newDst[14] = -m[14];\n        newDst[15] = -m[15];\n        return newDst;\n    }\n    /**\n     * add 2 matrices.\n     * @param a - matrix 1.\n     * @param b - matrix 2.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns a + b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        newDst[3] = a[3] + b[3];\n        newDst[4] = a[4] + b[4];\n        newDst[5] = a[5] + b[5];\n        newDst[6] = a[6] + b[6];\n        newDst[7] = a[7] + b[7];\n        newDst[8] = a[8] + b[8];\n        newDst[9] = a[9] + b[9];\n        newDst[10] = a[10] + b[10];\n        newDst[11] = a[11] + b[11];\n        newDst[12] = a[12] + b[12];\n        newDst[13] = a[13] + b[13];\n        newDst[14] = a[14] + b[14];\n        newDst[15] = a[15] + b[15];\n        return newDst;\n    }\n    /**\n     * Multiplies a matrix by a scalar\n     * @param m - The matrix.\n     * @param s - The scalar\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns m * s.\n     */\n    function multiplyScalar(m, s, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = m[0] * s;\n        newDst[1] = m[1] * s;\n        newDst[2] = m[2] * s;\n        newDst[3] = m[3] * s;\n        newDst[4] = m[4] * s;\n        newDst[5] = m[5] * s;\n        newDst[6] = m[6] * s;\n        newDst[7] = m[7] * s;\n        newDst[8] = m[8] * s;\n        newDst[9] = m[9] * s;\n        newDst[10] = m[10] * s;\n        newDst[11] = m[11] * s;\n        newDst[12] = m[12] * s;\n        newDst[13] = m[13] * s;\n        newDst[14] = m[14] * s;\n        newDst[15] = m[15] * s;\n        return newDst;\n    }\n    /**\n     * Multiplies a matrix by a scalar\n     * @param m - The matrix.\n     * @param s - The scalar\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns m * s.\n     */\n    const mulScalar = multiplyScalar;\n    /**\n     * Copies a matrix. (same as {@link mat4.clone})\n     * Also see {@link mat4.create} and {@link mat4.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    function copy(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = m[0];\n        newDst[1] = m[1];\n        newDst[2] = m[2];\n        newDst[3] = m[3];\n        newDst[4] = m[4];\n        newDst[5] = m[5];\n        newDst[6] = m[6];\n        newDst[7] = m[7];\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n        newDst[11] = m[11];\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n        return newDst;\n    }\n    /**\n     * Copies a matrix (same as {@link mat4.copy})\n     * Also see {@link mat4.create} and {@link mat4.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    const clone = copy;\n    /**\n     * Check if 2 matrices are approximately equal\n     * @param a - Operand matrix.\n     * @param b - Operand matrix.\n     * @returns true if matrices are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[3] - b[3]) < EPSILON &&\n            Math.abs(a[4] - b[4]) < EPSILON &&\n            Math.abs(a[5] - b[5]) < EPSILON &&\n            Math.abs(a[6] - b[6]) < EPSILON &&\n            Math.abs(a[7] - b[7]) < EPSILON &&\n            Math.abs(a[8] - b[8]) < EPSILON &&\n            Math.abs(a[9] - b[9]) < EPSILON &&\n            Math.abs(a[10] - b[10]) < EPSILON &&\n            Math.abs(a[11] - b[11]) < EPSILON &&\n            Math.abs(a[12] - b[12]) < EPSILON &&\n            Math.abs(a[13] - b[13]) < EPSILON &&\n            Math.abs(a[14] - b[14]) < EPSILON &&\n            Math.abs(a[15] - b[15]) < EPSILON;\n    }\n    /**\n     * Check if 2 matrices are exactly equal\n     * @param a - Operand matrix.\n     * @param b - Operand matrix.\n     * @returns true if matrices are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] &&\n            a[1] === b[1] &&\n            a[2] === b[2] &&\n            a[3] === b[3] &&\n            a[4] === b[4] &&\n            a[5] === b[5] &&\n            a[6] === b[6] &&\n            a[7] === b[7] &&\n            a[8] === b[8] &&\n            a[9] === b[9] &&\n            a[10] === b[10] &&\n            a[11] === b[11] &&\n            a[12] === b[12] &&\n            a[13] === b[13] &&\n            a[14] === b[14] &&\n            a[15] === b[15];\n    }\n    /**\n     * Creates a 4-by-4 identity matrix.\n     *\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A 4-by-4 identity matrix.\n     */\n    function identity(dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Takes the transpose of a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The transpose of m.\n     */\n    function transpose(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        if (newDst === m) {\n            let t;\n            t = m[1];\n            m[1] = m[4];\n            m[4] = t;\n            t = m[2];\n            m[2] = m[8];\n            m[8] = t;\n            t = m[3];\n            m[3] = m[12];\n            m[12] = t;\n            t = m[6];\n            m[6] = m[9];\n            m[9] = t;\n            t = m[7];\n            m[7] = m[13];\n            m[13] = t;\n            t = m[11];\n            m[11] = m[14];\n            m[14] = t;\n            return newDst;\n        }\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        newDst[0] = m00;\n        newDst[1] = m10;\n        newDst[2] = m20;\n        newDst[3] = m30;\n        newDst[4] = m01;\n        newDst[5] = m11;\n        newDst[6] = m21;\n        newDst[7] = m31;\n        newDst[8] = m02;\n        newDst[9] = m12;\n        newDst[10] = m22;\n        newDst[11] = m32;\n        newDst[12] = m03;\n        newDst[13] = m13;\n        newDst[14] = m23;\n        newDst[15] = m33;\n        return newDst;\n    }\n    /**\n     * Computes the inverse of a 4-by-4 matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    function inverse(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        const tmp0 = m22 * m33;\n        const tmp1 = m32 * m23;\n        const tmp2 = m12 * m33;\n        const tmp3 = m32 * m13;\n        const tmp4 = m12 * m23;\n        const tmp5 = m22 * m13;\n        const tmp6 = m02 * m33;\n        const tmp7 = m32 * m03;\n        const tmp8 = m02 * m23;\n        const tmp9 = m22 * m03;\n        const tmp10 = m02 * m13;\n        const tmp11 = m12 * m03;\n        const tmp12 = m20 * m31;\n        const tmp13 = m30 * m21;\n        const tmp14 = m10 * m31;\n        const tmp15 = m30 * m11;\n        const tmp16 = m10 * m21;\n        const tmp17 = m20 * m11;\n        const tmp18 = m00 * m31;\n        const tmp19 = m30 * m01;\n        const tmp20 = m00 * m21;\n        const tmp21 = m20 * m01;\n        const tmp22 = m00 * m11;\n        const tmp23 = m10 * m01;\n        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n        const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n        newDst[0] = d * t0;\n        newDst[1] = d * t1;\n        newDst[2] = d * t2;\n        newDst[3] = d * t3;\n        newDst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n            (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n        newDst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n            (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n        newDst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n            (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n        newDst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n            (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n        newDst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n            (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n        newDst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n            (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n        newDst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n            (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n        newDst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n            (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n        newDst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n            (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n        newDst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n            (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n        newDst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n            (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n        newDst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n            (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n        return newDst;\n    }\n    /**\n     * Compute the determinant of a matrix\n     * @param m - the matrix\n     * @returns the determinant\n     */\n    function determinant(m) {\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        const tmp0 = m22 * m33;\n        const tmp1 = m32 * m23;\n        const tmp2 = m12 * m33;\n        const tmp3 = m32 * m13;\n        const tmp4 = m12 * m23;\n        const tmp5 = m22 * m13;\n        const tmp6 = m02 * m33;\n        const tmp7 = m32 * m03;\n        const tmp8 = m02 * m23;\n        const tmp9 = m22 * m03;\n        const tmp10 = m02 * m13;\n        const tmp11 = m12 * m03;\n        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n        return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n    }\n    /**\n     * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    const invert = inverse;\n    /**\n     * Multiplies two 4-by-4 matrices with a on the left and b on the right\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4 + 0];\n        const a11 = a[4 + 1];\n        const a12 = a[4 + 2];\n        const a13 = a[4 + 3];\n        const a20 = a[8 + 0];\n        const a21 = a[8 + 1];\n        const a22 = a[8 + 2];\n        const a23 = a[8 + 3];\n        const a30 = a[12 + 0];\n        const a31 = a[12 + 1];\n        const a32 = a[12 + 2];\n        const a33 = a[12 + 3];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4 + 0];\n        const b11 = b[4 + 1];\n        const b12 = b[4 + 2];\n        const b13 = b[4 + 3];\n        const b20 = b[8 + 0];\n        const b21 = b[8 + 1];\n        const b22 = b[8 + 2];\n        const b23 = b[8 + 3];\n        const b30 = b[12 + 0];\n        const b31 = b[12 + 1];\n        const b32 = b[12 + 2];\n        const b33 = b[12 + 3];\n        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n        newDst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n        newDst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n        newDst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n        newDst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n        newDst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n        newDst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n        newDst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n        return newDst;\n    }\n    /**\n     * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Sets the translation component of a 4-by-4 matrix to the given\n     * vector.\n     * @param a - The matrix.\n     * @param v - The vector.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix with translation set.\n     */\n    function setTranslation(a, v, dst) {\n        const newDst = (dst ?? identity());\n        if (a !== newDst) {\n            newDst[0] = a[0];\n            newDst[1] = a[1];\n            newDst[2] = a[2];\n            newDst[3] = a[3];\n            newDst[4] = a[4];\n            newDst[5] = a[5];\n            newDst[6] = a[6];\n            newDst[7] = a[7];\n            newDst[8] = a[8];\n            newDst[9] = a[9];\n            newDst[10] = a[10];\n            newDst[11] = a[11];\n        }\n        newDst[12] = v[0];\n        newDst[13] = v[1];\n        newDst[14] = v[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    ///**\n    // * Returns the translation component of a 4-by-4 matrix as a vector with 3\n    // * entries.\n    // * @param m - The matrix.\n    // * @param dst - vector to hold result. If not passed a new one is created.\n    // * @returns The translation component of m.\n    // */\n    function getTranslation(m, dst) {\n        const newDst = (dst ?? vec3.create());\n        newDst[0] = m[12];\n        newDst[1] = m[13];\n        newDst[2] = m[14];\n        return newDst;\n    }\n    /**\n     * Returns an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y, 2 = z;\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n        const newDst = (dst ?? vec3.create());\n        const off = axis * 4;\n        newDst[0] = m[off + 0];\n        newDst[1] = m[off + 1];\n        newDst[2] = m[off + 2];\n        return newDst;\n    }\n    /**\n     * Sets an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param v - the axis vector\n     * @param axis - The axis  0 = x, 1 = y, 2 = z;\n     * @param dst - The matrix to set. If not passed a new one is created.\n     * @returns The matrix with axis set.\n     */\n    function setAxis(m, v, axis, dst) {\n        const newDst = (dst === m) ? dst : copy(m, dst);\n        const off = axis * 4;\n        newDst[off + 0] = v[0];\n        newDst[off + 1] = v[1];\n        newDst[off + 2] = v[2];\n        return newDst;\n    }\n    /**\n     * Returns the \"3d\" scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function getScaling(m, dst) {\n        const newDst = (dst ?? vec3.create());\n        const xx = m[0];\n        const xy = m[1];\n        const xz = m[2];\n        const yx = m[4];\n        const yy = m[5];\n        const yz = m[6];\n        const zx = m[8];\n        const zy = m[9];\n        const zz = m[10];\n        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 perspective transformation matrix given the angular height\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n     * arguments define a frustum extending in the negative z direction.  The given\n     * angle is the vertical angle of the frustum, and the horizontal angle is\n     * determined to produce the given aspect ratio.  The arguments near and far are\n     * the distances to the near and far clipping planes.  Note that near and far\n     * are not z coordinates, but rather they are distances along the negative\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n     * from 0 to 1 in the z dimension.\n     *\n     * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n     * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n     * otherwise.\n     *\n     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n     * @param aspect - The aspect ratio width / height.\n     * @param zNear - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param zFar - The depth (negative z coordinate)\n     *     of the far clipping plane.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The perspective matrix.\n     */\n    function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n        newDst[0] = f / aspect;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = f;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[15] = 0;\n        if (Number.isFinite(zFar)) {\n            const rangeInv = 1 / (zNear - zFar);\n            newDst[10] = zFar * rangeInv;\n            newDst[14] = zFar * zNear * rangeInv;\n        }\n        else {\n            newDst[10] = -1;\n            newDst[14] = -zNear;\n        }\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n     * arguments define a frustum extending in the negative z direction.  The given\n     * angle is the vertical angle of the frustum, and the horizontal angle is\n     * determined to produce the given aspect ratio.  The arguments near and far are\n     * the distances to the near and far clipping planes.  Note that near and far\n     * are not z coordinates, but rather they are distances along the negative\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n     * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.\n     *\n     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n     * @param aspect - The aspect ratio width / height.\n     * @param zNear - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param zFar - The depth (negative z coordinate)\n     *     of the far clipping plane. (default = Infinity)\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The perspective matrix.\n     */ function perspectiveReverseZ(fieldOfViewYInRadians, aspect, zNear, zFar = Infinity, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);\n        newDst[0] = f / aspect;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = f;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[15] = 0;\n        if (zFar === Infinity) {\n            newDst[10] = 0;\n            newDst[14] = zNear;\n        }\n        else {\n            const rangeInv = 1 / (zFar - zNear);\n            newDst[10] = zNear * rangeInv;\n            newDst[14] = zFar * zNear * rangeInv;\n        }\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n     * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n     * and 0 to +1 in z.\n     * @param left - Left side of the near clipping plane viewport.\n     * @param right - Right side of the near clipping plane viewport.\n     * @param bottom - Bottom of the near clipping plane viewport.\n     * @param top - Top of the near clipping plane viewport.\n     * @param near - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param far - The depth (negative z coordinate)\n     *     of the far clipping plane.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The orthographic projection matrix.\n     */\n    function ortho(left, right, bottom, top, near, far, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = 2 / (right - left);\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 2 / (top - bottom);\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1 / (near - far);\n        newDst[11] = 0;\n        newDst[12] = (right + left) / (left - right);\n        newDst[13] = (top + bottom) / (bottom - top);\n        newDst[14] = near / (near - far);\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 perspective transformation matrix given the left, right,\n     * top, bottom, near and far clipping planes. The arguments define a frustum\n     * extending in the negative z direction. The arguments near and far are the\n     * distances to the near and far clipping planes. Note that near and far are not\n     * z coordinates, but rather they are distances along the negative z-axis. The\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\n     * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n     * dimension.\n     * @param left - The x coordinate of the left plane of the box.\n     * @param right - The x coordinate of the right plane of the box.\n     * @param bottom - The y coordinate of the bottom plane of the box.\n     * @param top - The y coordinate of the right plane of the box.\n     * @param near - The negative z coordinate of the near plane of the box.\n     * @param far - The negative z coordinate of the far plane of the box.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The perspective projection matrix.\n     */\n    function frustum(left, right, bottom, top, near, far, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const dx = (right - left);\n        const dy = (top - bottom);\n        const dz = (near - far);\n        newDst[0] = 2 * near / dx;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 2 * near / dy;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = (left + right) / dx;\n        newDst[9] = (top + bottom) / dy;\n        newDst[10] = far / dz;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = near * far / dz;\n        newDst[15] = 0;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,\n     * top, bottom, near and far clipping planes. The arguments define a frustum\n     * extending in the negative z direction. The arguments near and far are the\n     * distances to the near and far clipping planes. Note that near and far are not\n     * z coordinates, but rather they are distances along the negative z-axis. The\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\n     * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z\n     * dimension.\n     * @param left - The x coordinate of the left plane of the box.\n     * @param right - The x coordinate of the right plane of the box.\n     * @param bottom - The y coordinate of the bottom plane of the box.\n     * @param top - The y coordinate of the right plane of the box.\n     * @param near - The negative z coordinate of the near plane of the box.\n     * @param far - The negative z coordinate of the far plane of the box.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The perspective projection matrix.\n     */\n    function frustumReverseZ(left, right, bottom, top, near, far = Infinity, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const dx = (right - left);\n        const dy = (top - bottom);\n        newDst[0] = 2 * near / dx;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 2 * near / dy;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = (left + right) / dx;\n        newDst[9] = (top + bottom) / dy;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[15] = 0;\n        if (far === Infinity) {\n            newDst[10] = 0;\n            newDst[14] = near;\n        }\n        else {\n            const rangeInv = 1 / (far - near);\n            newDst[10] = near * rangeInv;\n            newDst[14] = far * near * rangeInv;\n        }\n        return newDst;\n    }\n    const xAxis = vec3.create();\n    const yAxis = vec3.create();\n    const zAxis = vec3.create();\n    /**\n     * Computes a 4-by-4 aim transformation.\n     *\n     * This is a matrix which positions an object aiming down positive Z.\n     * toward the target.\n     *\n     * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n     *\n     * @param position - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The aim matrix.\n     */\n    function aim(position, target, up, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        vec3.normalize(vec3.subtract(target, position, zAxis), zAxis);\n        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n        newDst[0] = xAxis[0];\n        newDst[1] = xAxis[1];\n        newDst[2] = xAxis[2];\n        newDst[3] = 0;\n        newDst[4] = yAxis[0];\n        newDst[5] = yAxis[1];\n        newDst[6] = yAxis[2];\n        newDst[7] = 0;\n        newDst[8] = zAxis[0];\n        newDst[9] = zAxis[1];\n        newDst[10] = zAxis[2];\n        newDst[11] = 0;\n        newDst[12] = position[0];\n        newDst[13] = position[1];\n        newDst[14] = position[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 camera aim transformation.\n     *\n     * This is a matrix which positions an object aiming down negative Z.\n     * toward the target.\n     *\n     * Note: this is the inverse of `lookAt`\n     *\n     * @param eye - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The aim matrix.\n     */\n    function cameraAim(eye, target, up, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n        newDst[0] = xAxis[0];\n        newDst[1] = xAxis[1];\n        newDst[2] = xAxis[2];\n        newDst[3] = 0;\n        newDst[4] = yAxis[0];\n        newDst[5] = yAxis[1];\n        newDst[6] = yAxis[2];\n        newDst[7] = 0;\n        newDst[8] = zAxis[0];\n        newDst[9] = zAxis[1];\n        newDst[10] = zAxis[2];\n        newDst[11] = 0;\n        newDst[12] = eye[0];\n        newDst[13] = eye[1];\n        newDst[14] = eye[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 view transformation.\n     *\n     * This is a view matrix which transforms all other objects\n     * to be in the space of the view defined by the parameters.\n     *\n     * @param eye - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The look-at matrix.\n     */\n    function lookAt(eye, target, up, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n        newDst[0] = xAxis[0];\n        newDst[1] = yAxis[0];\n        newDst[2] = zAxis[0];\n        newDst[3] = 0;\n        newDst[4] = xAxis[1];\n        newDst[5] = yAxis[1];\n        newDst[6] = zAxis[1];\n        newDst[7] = 0;\n        newDst[8] = xAxis[2];\n        newDst[9] = yAxis[2];\n        newDst[10] = zAxis[2];\n        newDst[11] = 0;\n        newDst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n        newDst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n        newDst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which translates by the given vector v.\n     * @param v - The vector by\n     *     which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translation matrix.\n     */\n    function translation(v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        newDst[11] = 0;\n        newDst[12] = v[0];\n        newDst[13] = v[1];\n        newDst[14] = v[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Translates the given 4-by-4 matrix by the given vector v.\n     * @param m - The matrix.\n     * @param v - The vector by\n     *     which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translated matrix.\n     */\n    function translate(m, v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const m00 = m[0];\n        const m01 = m[1];\n        const m02 = m[2];\n        const m03 = m[3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        if (m !== newDst) {\n            newDst[0] = m00;\n            newDst[1] = m01;\n            newDst[2] = m02;\n            newDst[3] = m03;\n            newDst[4] = m10;\n            newDst[5] = m11;\n            newDst[6] = m12;\n            newDst[7] = m13;\n            newDst[8] = m20;\n            newDst[9] = m21;\n            newDst[10] = m22;\n            newDst[11] = m23;\n        }\n        newDst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n        newDst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n        newDst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n        newDst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationX(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = c;\n        newDst[6] = s;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = -s;\n        newDst[10] = c;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the x-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateX(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m10 = m[4];\n        const m11 = m[5];\n        const m12 = m[6];\n        const m13 = m[7];\n        const m20 = m[8];\n        const m21 = m[9];\n        const m22 = m[10];\n        const m23 = m[11];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[4] = c * m10 + s * m20;\n        newDst[5] = c * m11 + s * m21;\n        newDst[6] = c * m12 + s * m22;\n        newDst[7] = c * m13 + s * m23;\n        newDst[8] = c * m20 - s * m10;\n        newDst[9] = c * m21 - s * m11;\n        newDst[10] = c * m22 - s * m12;\n        newDst[11] = c * m23 - s * m13;\n        if (m !== newDst) {\n            newDst[0] = m[0];\n            newDst[1] = m[1];\n            newDst[2] = m[2];\n            newDst[3] = m[3];\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationY(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c;\n        newDst[1] = 0;\n        newDst[2] = -s;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = s;\n        newDst[9] = 0;\n        newDst[10] = c;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the y-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateY(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c * m00 - s * m20;\n        newDst[1] = c * m01 - s * m21;\n        newDst[2] = c * m02 - s * m22;\n        newDst[3] = c * m03 - s * m23;\n        newDst[8] = c * m20 + s * m00;\n        newDst[9] = c * m21 + s * m01;\n        newDst[10] = c * m22 + s * m02;\n        newDst[11] = c * m23 + s * m03;\n        if (m !== newDst) {\n            newDst[4] = m[4];\n            newDst[5] = m[5];\n            newDst[6] = m[6];\n            newDst[7] = m[7];\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationZ(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c;\n        newDst[1] = s;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = -s;\n        newDst[5] = c;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the z-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateZ(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c * m00 + s * m10;\n        newDst[1] = c * m01 + s * m11;\n        newDst[2] = c * m02 + s * m12;\n        newDst[3] = c * m03 + s * m13;\n        newDst[4] = c * m10 - s * m00;\n        newDst[5] = c * m11 - s * m01;\n        newDst[6] = c * m12 - s * m02;\n        newDst[7] = c * m13 - s * m03;\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n            newDst[11] = m[11];\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the given axis by the given\n     * angle.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A matrix which rotates angle radians\n     *     around the axis.\n     */\n    function axisRotation(axis, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        let x = axis[0];\n        let y = axis[1];\n        let z = axis[2];\n        const n = Math.sqrt(x * x + y * y + z * z);\n        x /= n;\n        y /= n;\n        z /= n;\n        const xx = x * x;\n        const yy = y * y;\n        const zz = z * z;\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        const oneMinusCosine = 1 - c;\n        newDst[0] = xx + (1 - xx) * c;\n        newDst[1] = x * y * oneMinusCosine + z * s;\n        newDst[2] = x * z * oneMinusCosine - y * s;\n        newDst[3] = 0;\n        newDst[4] = x * y * oneMinusCosine - z * s;\n        newDst[5] = yy + (1 - yy) * c;\n        newDst[6] = y * z * oneMinusCosine + x * s;\n        newDst[7] = 0;\n        newDst[8] = x * z * oneMinusCosine + y * s;\n        newDst[9] = y * z * oneMinusCosine - x * s;\n        newDst[10] = zz + (1 - zz) * c;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the given axis by the given\n     * angle. (same as axisRotation)\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A matrix which rotates angle radians\n     *     around the axis.\n     */\n    const rotation = axisRotation;\n    /**\n     * Rotates the given 4-by-4 matrix around the given axis by the\n     * given angle.\n     * @param m - The matrix.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function axisRotate(m, axis, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        let x = axis[0];\n        let y = axis[1];\n        let z = axis[2];\n        const n = Math.sqrt(x * x + y * y + z * z);\n        x /= n;\n        y /= n;\n        z /= n;\n        const xx = x * x;\n        const yy = y * y;\n        const zz = z * z;\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        const oneMinusCosine = 1 - c;\n        const r00 = xx + (1 - xx) * c;\n        const r01 = x * y * oneMinusCosine + z * s;\n        const r02 = x * z * oneMinusCosine - y * s;\n        const r10 = x * y * oneMinusCosine - z * s;\n        const r11 = yy + (1 - yy) * c;\n        const r12 = y * z * oneMinusCosine + x * s;\n        const r20 = x * z * oneMinusCosine + y * s;\n        const r21 = y * z * oneMinusCosine - x * s;\n        const r22 = zz + (1 - zz) * c;\n        const m00 = m[0];\n        const m01 = m[1];\n        const m02 = m[2];\n        const m03 = m[3];\n        const m10 = m[4];\n        const m11 = m[5];\n        const m12 = m[6];\n        const m13 = m[7];\n        const m20 = m[8];\n        const m21 = m[9];\n        const m22 = m[10];\n        const m23 = m[11];\n        newDst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n        newDst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n        newDst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n        newDst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n        newDst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n        newDst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n        newDst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n        newDst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n        newDst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n        newDst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n        newDst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n        newDst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n        if (m !== newDst) {\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the given axis by the\n     * given angle. (same as rotate)\n     * @param m - The matrix.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    const rotate = axisRotate;\n    /**\n     * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has three\n     * entries.\n     * @param v - A vector of\n     *     three entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling(v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = v[0];\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = v[1];\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = v[2];\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 4-by-4 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * three entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of three entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale(m, v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        newDst[0] = v0 * m[0 * 4 + 0];\n        newDst[1] = v0 * m[0 * 4 + 1];\n        newDst[2] = v0 * m[0 * 4 + 2];\n        newDst[3] = v0 * m[0 * 4 + 3];\n        newDst[4] = v1 * m[1 * 4 + 0];\n        newDst[5] = v1 * m[1 * 4 + 1];\n        newDst[6] = v1 * m[1 * 4 + 2];\n        newDst[7] = v1 * m[1 * 4 + 3];\n        newDst[8] = v2 * m[2 * 4 + 0];\n        newDst[9] = v2 * m[2 * 4 + 1];\n        newDst[10] = v2 * m[2 * 4 + 2];\n        newDst[11] = v2 * m[2 * 4 + 3];\n        if (m !== newDst) {\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.\n     * @param s - the amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling(s, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = s;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = s;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = s;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 4-by-4 matrix in each dimension by a uniform scale.\n     * @param m - The matrix to be modified.\n     * @param s - The amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale(m, s, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = s * m[0 * 4 + 0];\n        newDst[1] = s * m[0 * 4 + 1];\n        newDst[2] = s * m[0 * 4 + 2];\n        newDst[3] = s * m[0 * 4 + 3];\n        newDst[4] = s * m[1 * 4 + 0];\n        newDst[5] = s * m[1 * 4 + 1];\n        newDst[6] = s * m[1 * 4 + 2];\n        newDst[7] = s * m[1 * 4 + 3];\n        newDst[8] = s * m[2 * 4 + 0];\n        newDst[9] = s * m[2 * 4 + 1];\n        newDst[10] = s * m[2 * 4 + 2];\n        newDst[11] = s * m[2 * 4 + 3];\n        if (m !== newDst) {\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    return {\n        add,\n        aim,\n        axisRotate,\n        axisRotation,\n        cameraAim,\n        clone,\n        copy,\n        create,\n        determinant,\n        equals,\n        equalsApproximately,\n        fromMat3,\n        fromQuat,\n        frustum,\n        frustumReverseZ,\n        getAxis,\n        getScaling,\n        getTranslation,\n        identity,\n        inverse,\n        invert,\n        lookAt,\n        mul,\n        mulScalar,\n        multiply,\n        multiplyScalar,\n        negate,\n        ortho,\n        perspective,\n        perspectiveReverseZ,\n        rotate,\n        rotateX,\n        rotateY,\n        rotateZ,\n        rotation,\n        rotationX,\n        rotationY,\n        rotationZ,\n        scale,\n        scaling,\n        set,\n        setAxis,\n        setTranslation,\n        translate,\n        translation,\n        transpose,\n        uniformScale,\n        uniformScaling,\n    };\n}\nconst cache$2 = new Map();\nfunction getAPI$2(Ctor) {\n    let api = cache$2.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$2(Ctor);\n        cache$2.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Qud\n * */\nfunction getAPIImpl$1(Ctor) {\n    const vec3 = getAPI$4(Ctor);\n    /**\n     * Creates a quat4; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param w - Initial w value.\n     * @returns the created vector\n     */\n    function create(x, y, z, w) {\n        const newDst = new Ctor(4);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n                if (z !== undefined) {\n                    newDst[2] = z;\n                    if (w !== undefined) {\n                        newDst[3] = w;\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param z - Initial w value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Quat\n     * Also see {@link quat.create} and {@link quat.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param w fourth value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, w, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = x;\n        newDst[1] = y;\n        newDst[2] = z;\n        newDst[3] = w;\n        return newDst;\n    }\n    /**\n     * Sets a quaternion from the given angle and  axis,\n     * then returns it.\n     *\n     * @param axis - the axis to rotate around\n     * @param angleInRadians - the angle\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The quaternion that represents the given axis and angle\n     **/\n    function fromAxisAngle(axis, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const s = Math.sin(halfAngle);\n        newDst[0] = s * axis[0];\n        newDst[1] = s * axis[1];\n        newDst[2] = s * axis[2];\n        newDst[3] = Math.cos(halfAngle);\n        return newDst;\n    }\n    /**\n     * Gets the rotation axis and angle\n     * @param q - quaternion to compute from\n     * @param dst - Vec3 to hold result. If not passed in a new one is created.\n     * @return angle and axis\n     */\n    function toAxisAngle(q, dst) {\n        const newDst = (dst ?? vec3.create(3));\n        const angle = Math.acos(q[3]) * 2;\n        const s = Math.sin(angle * 0.5);\n        if (s > EPSILON) {\n            newDst[0] = q[0] / s;\n            newDst[1] = q[1] / s;\n            newDst[2] = q[2] / s;\n        }\n        else {\n            newDst[0] = 1;\n            newDst[1] = 0;\n            newDst[2] = 0;\n        }\n        return { angle, axis: newDst };\n    }\n    /**\n     * Returns the angle in degrees between two rotations a and b.\n     * @param a - quaternion a\n     * @param b - quaternion b\n     * @return angle in radians between the two quaternions\n     */\n    function angle(a, b) {\n        const d = dot(a, b);\n        return Math.acos(2 * d * d - 1);\n    }\n    /**\n     * Multiplies two quaternions\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const aw = a[3];\n        const bx = b[0];\n        const by = b[1];\n        const bz = b[2];\n        const bw = b[3];\n        newDst[0] = ax * bw + aw * bx + ay * bz - az * by;\n        newDst[1] = ay * bw + aw * by + az * bx - ax * bz;\n        newDst[2] = az * bw + aw * bz + ax * by - ay * bx;\n        newDst[3] = aw * bw - ax * bx - ay * by - az * bz;\n        return newDst;\n    }\n    /**\n     * Multiplies two quaternions\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    const mul = multiply;\n    /**\n     * Rotates the given quaternion around the X axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateX(q, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n        const bx = Math.sin(halfAngle);\n        const bw = Math.cos(halfAngle);\n        newDst[0] = qx * bw + qw * bx;\n        newDst[1] = qy * bw + qz * bx;\n        newDst[2] = qz * bw - qy * bx;\n        newDst[3] = qw * bw - qx * bx;\n        return newDst;\n    }\n    /**\n     * Rotates the given quaternion around the Y axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateY(q, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n        const by = Math.sin(halfAngle);\n        const bw = Math.cos(halfAngle);\n        newDst[0] = qx * bw - qz * by;\n        newDst[1] = qy * bw + qw * by;\n        newDst[2] = qz * bw + qx * by;\n        newDst[3] = qw * bw - qy * by;\n        return newDst;\n    }\n    /**\n     * Rotates the given quaternion around the Z axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateZ(q, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n        const bz = Math.sin(halfAngle);\n        const bw = Math.cos(halfAngle);\n        newDst[0] = qx * bw + qy * bz;\n        newDst[1] = qy * bw - qx * bz;\n        newDst[2] = qz * bw + qw * bz;\n        newDst[3] = qw * bw - qz * bz;\n        return newDst;\n    }\n    /**\n     * Spherically linear interpolate between two quaternions\n     *\n     * @param a - starting value\n     * @param b - ending value\n     * @param t - value where 0 = a and 1 = b\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function slerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const aw = a[3];\n        let bx = b[0];\n        let by = b[1];\n        let bz = b[2];\n        let bw = b[3];\n        let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n        if (cosOmega < 0) {\n            cosOmega = -cosOmega;\n            bx = -bx;\n            by = -by;\n            bz = -bz;\n            bw = -bw;\n        }\n        let scale0;\n        let scale1;\n        if (1.0 - cosOmega > EPSILON) {\n            const omega = Math.acos(cosOmega);\n            const sinOmega = Math.sin(omega);\n            scale0 = Math.sin((1 - t) * omega) / sinOmega;\n            scale1 = Math.sin(t * omega) / sinOmega;\n        }\n        else {\n            scale0 = 1.0 - t;\n            scale1 = t;\n        }\n        newDst[0] = scale0 * ax + scale1 * bx;\n        newDst[1] = scale0 * ay + scale1 * by;\n        newDst[2] = scale0 * az + scale1 * bz;\n        newDst[3] = scale0 * aw + scale1 * bw;\n        return newDst;\n    }\n    /**\n     * Compute the inverse of a quaternion\n     *\n     * @param q - quaternion to compute the inverse of\n     * @returns A quaternion that is the result of a * b\n     */\n    function inverse(q, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const a0 = q[0];\n        const a1 = q[1];\n        const a2 = q[2];\n        const a3 = q[3];\n        const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n        const invDot = dot ? 1 / dot : 0;\n        newDst[0] = -a0 * invDot;\n        newDst[1] = -a1 * invDot;\n        newDst[2] = -a2 * invDot;\n        newDst[3] = a3 * invDot;\n        return newDst;\n    }\n    /**\n     * Compute the conjugate of a quaternion\n     * For quaternions with a magnitude of 1 (a unit quaternion)\n     * this returns the same as the inverse but is faster to calculate.\n     *\n     * @param q - quaternion to compute the conjugate of.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The conjugate of q\n     */\n    function conjugate(q, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = -q[0];\n        newDst[1] = -q[1];\n        newDst[2] = -q[2];\n        newDst[3] = q[3];\n        return newDst;\n    }\n    /**\n     * Creates a quaternion from the given rotation matrix.\n     *\n     * The created quaternion is not normalized.\n     *\n     * @param m - rotation matrix\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns the result\n     */\n    function fromMat(m, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        /*\n        0 1 2\n        3 4 5\n        6 7 8\n      \n        0 1 2\n        4 5 6\n        8 9 10\n         */\n        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n        // article \"Quaternion Calculus and Fast Animation\".\n        const trace = m[0] + m[5] + m[10];\n        if (trace > 0.0) {\n            // |w| > 1/2, may as well choose w > 1/2\n            const root = Math.sqrt(trace + 1); // 2w\n            newDst[3] = 0.5 * root;\n            const invRoot = 0.5 / root; // 1/(4w)\n            newDst[0] = (m[6] - m[9]) * invRoot;\n            newDst[1] = (m[8] - m[2]) * invRoot;\n            newDst[2] = (m[1] - m[4]) * invRoot;\n        }\n        else {\n            // |w| <= 1/2\n            let i = 0;\n            if (m[5] > m[0]) {\n                i = 1;\n            }\n            if (m[10] > m[i * 4 + i]) {\n                i = 2;\n            }\n            const j = (i + 1) % 3;\n            const k = (i + 2) % 3;\n            const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n            newDst[i] = 0.5 * root;\n            const invRoot = 0.5 / root;\n            newDst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n            newDst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n            newDst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n        }\n        return newDst;\n    }\n    /**\n     * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n     *\n     * @param xAngleInRadians - angle to rotate around X axis in radians.\n     * @param yAngleInRadians - angle to rotate around Y axis in radians.\n     * @param zAngleInRadians - angle to rotate around Z axis in radians.\n     * @param order - order to apply euler angles\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n     */\n    function fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const xHalfAngle = xAngleInRadians * 0.5;\n        const yHalfAngle = yAngleInRadians * 0.5;\n        const zHalfAngle = zAngleInRadians * 0.5;\n        const sx = Math.sin(xHalfAngle);\n        const cx = Math.cos(xHalfAngle);\n        const sy = Math.sin(yHalfAngle);\n        const cy = Math.cos(yHalfAngle);\n        const sz = Math.sin(zHalfAngle);\n        const cz = Math.cos(zHalfAngle);\n        switch (order) {\n            case 'xyz':\n                newDst[0] = sx * cy * cz + cx * sy * sz;\n                newDst[1] = cx * sy * cz - sx * cy * sz;\n                newDst[2] = cx * cy * sz + sx * sy * cz;\n                newDst[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case 'xzy':\n                newDst[0] = sx * cy * cz - cx * sy * sz;\n                newDst[1] = cx * sy * cz - sx * cy * sz;\n                newDst[2] = cx * cy * sz + sx * sy * cz;\n                newDst[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            case 'yxz':\n                newDst[0] = sx * cy * cz + cx * sy * sz;\n                newDst[1] = cx * sy * cz - sx * cy * sz;\n                newDst[2] = cx * cy * sz - sx * sy * cz;\n                newDst[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            case 'yzx':\n                newDst[0] = sx * cy * cz + cx * sy * sz;\n                newDst[1] = cx * sy * cz + sx * cy * sz;\n                newDst[2] = cx * cy * sz - sx * sy * cz;\n                newDst[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case 'zxy':\n                newDst[0] = sx * cy * cz - cx * sy * sz;\n                newDst[1] = cx * sy * cz + sx * cy * sz;\n                newDst[2] = cx * cy * sz + sx * sy * cz;\n                newDst[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case 'zyx':\n                newDst[0] = sx * cy * cz - cx * sy * sz;\n                newDst[1] = cx * sy * cz + sx * cy * sz;\n                newDst[2] = cx * cy * sz - sx * sy * cz;\n                newDst[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            default:\n                throw new Error(`Unknown rotation order: ${order}`);\n        }\n        return newDst;\n    }\n    /**\n     * Copies a quaternion. (same as {@link quat.clone})\n     * Also see {@link quat.create} and {@link quat.set}\n     * @param q - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is a copy of q\n     */\n    function copy(q, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = q[0];\n        newDst[1] = q[1];\n        newDst[2] = q[2];\n        newDst[3] = q[3];\n        return newDst;\n    }\n    /**\n     * Clones a quaternion. (same as {@link quat.copy})\n     * Also see {@link quat.create} and {@link quat.set}\n     * @param q - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A copy of q.\n     */\n    const clone = copy;\n    /**\n     * Adds two quaternions; assumes a and b have the same dimension.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        newDst[3] = a[3] + b[3];\n        return newDst;\n    }\n    /**\n     * Subtracts two quaternions.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        newDst[2] = a[2] - b[2];\n        newDst[3] = a[3] - b[3];\n        return newDst;\n    }\n    /**\n     * Subtracts two quaternions.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Multiplies a quaternion by a scalar.\n     * @param v - The quaternion.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        newDst[2] = v[2] * k;\n        newDst[3] = v[3] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a quaternion by a scalar. (same as mulScalar)\n     * @param v - The quaternion.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        newDst[2] = v[2] / k;\n        newDst[3] = v[3] / k;\n        return newDst;\n    }\n    /**\n     * Computes the dot product of two quaternions\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n    }\n    /**\n     * Performs linear interpolation on two quaternions.\n     * Given quaternions a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param t - Interpolation coefficient.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        newDst[2] = a[2] + t * (b[2] - a[2]);\n        newDst[3] = a[3] + t * (b[3] - a[3]);\n        return newDst;\n    }\n    /**\n     * Computes the length of quaternion\n     * @param v - quaternion.\n     * @returns length of quaternion.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    }\n    /**\n     * Computes the length of quaternion (same as length)\n     * @param v - quaternion.\n     * @returns length of quaternion.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of quaternion\n     * @param v - quaternion.\n     * @returns square of the length of quaternion.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n    }\n    /**\n     * Computes the square of the length of quaternion (same as lengthSq)\n     * @param v - quaternion.\n     * @returns square of the length of quaternion.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Divides a quaternion by its Euclidean length and returns the quotient.\n     * @param v - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The normalized quaternion.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n            newDst[2] = v2 / len;\n            newDst[3] = v3 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n            newDst[3] = 1;\n        }\n        return newDst;\n    }\n    /**\n     * Check if 2 quaternions are approximately equal\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns true if quaternions are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[3] - b[3]) < EPSILON;\n    }\n    /**\n     * Check if 2 quaternions are exactly equal\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns true if quaternions are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n    }\n    /**\n     * Creates an identity quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns an identity quaternion\n     */\n    function identity(dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 1;\n        return newDst;\n    }\n    const tempVec3 = vec3.create();\n    const xUnitVec3 = vec3.create();\n    const yUnitVec3 = vec3.create();\n    /**\n     * Computes a quaternion to represent the shortest rotation from one vector to another.\n     *\n     * @param aUnit - the start vector\n     * @param bUnit - the end vector\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns the result\n     */\n    function rotationTo(aUnit, bUnit, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const dot = vec3.dot(aUnit, bUnit);\n        if (dot < -0.999999) {\n            vec3.cross(xUnitVec3, aUnit, tempVec3);\n            if (vec3.len(tempVec3) < 0.000001) {\n                vec3.cross(yUnitVec3, aUnit, tempVec3);\n            }\n            vec3.normalize(tempVec3, tempVec3);\n            fromAxisAngle(tempVec3, Math.PI, newDst);\n            return newDst;\n        }\n        else if (dot > 0.999999) {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n            newDst[3] = 1;\n            return newDst;\n        }\n        else {\n            vec3.cross(aUnit, bUnit, tempVec3);\n            newDst[0] = tempVec3[0];\n            newDst[1] = tempVec3[1];\n            newDst[2] = tempVec3[2];\n            newDst[3] = 1 + dot;\n            return normalize(newDst, newDst);\n        }\n    }\n    const tempQuat1 = new Ctor(4);\n    const tempQuat2 = new Ctor(4);\n    /**\n     * Performs a spherical linear interpolation with two control points\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param c - the third quaternion\n     * @param d - the fourth quaternion\n     * @param t - Interpolation coefficient 0 to 1\n     * @returns result\n     */\n    function sqlerp(a, b, c, d, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        slerp(a, d, t, tempQuat1);\n        slerp(b, c, t, tempQuat2);\n        slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), newDst);\n        return newDst;\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        fromAxisAngle,\n        toAxisAngle,\n        angle,\n        multiply,\n        mul,\n        rotateX,\n        rotateY,\n        rotateZ,\n        slerp,\n        inverse,\n        conjugate,\n        fromMat,\n        fromEuler,\n        copy,\n        clone,\n        add,\n        subtract,\n        sub,\n        mulScalar,\n        scale,\n        divScalar,\n        dot,\n        lerp,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        normalize,\n        equalsApproximately,\n        equals,\n        identity,\n        rotationTo,\n        sqlerp,\n    };\n}\nconst cache$1 = new Map();\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `newDst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nfunction getAPI$1(Ctor) {\n    let api = cache$1.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$1(Ctor);\n        cache$1.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Vec4\n * */\nfunction getAPIImpl(Ctor) {\n    /**\n     * Creates a vec4; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param w - Initial w value.\n     * @returns the created vector\n     */\n    function create(x, y, z, w) {\n        const newDst = new Ctor(4);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n                if (z !== undefined) {\n                    newDst[2] = z;\n                    if (w !== undefined) {\n                        newDst[3] = w;\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param z - Initial w value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Vec4\n     * Also see {@link vec4.create} and {@link vec4.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param w fourth value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, w, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = x;\n        newDst[1] = y;\n        newDst[2] = z;\n        newDst[3] = w;\n        return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.ceil(v[0]);\n        newDst[1] = Math.ceil(v[1]);\n        newDst[2] = Math.ceil(v[2]);\n        newDst[3] = Math.ceil(v[3]);\n        return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.floor(v[0]);\n        newDst[1] = Math.floor(v[1]);\n        newDst[2] = Math.floor(v[2]);\n        newDst[3] = Math.floor(v[3]);\n        return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.round(v[0]);\n        newDst[1] = Math.round(v[1]);\n        newDst[2] = Math.round(v[2]);\n        newDst[3] = Math.round(v[3]);\n        return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v, min = 0, max = 1, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.min(max, Math.max(min, v[0]));\n        newDst[1] = Math.min(max, Math.max(min, v[1]));\n        newDst[2] = Math.min(max, Math.max(min, v[2]));\n        newDst[3] = Math.min(max, Math.max(min, v[3]));\n        return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        newDst[3] = a[3] + b[3];\n        return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + b[0] * scale;\n        newDst[1] = a[1] + b[1] * scale;\n        newDst[2] = a[2] + b[2] * scale;\n        newDst[3] = a[3] + b[3] * scale;\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        newDst[2] = a[2] - b[2];\n        newDst[3] = a[3] - b[3];\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[3] - b[3]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        newDst[2] = a[2] + t * (b[2] - a[2]);\n        newDst[3] = a[3] + t * (b[3] - a[3]);\n        return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n        newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n        newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n        newDst[3] = a[3] + t[3] * (b[3] - a[3]);\n        return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.max(a[0], b[0]);\n        newDst[1] = Math.max(a[1], b[1]);\n        newDst[2] = Math.max(a[2], b[2]);\n        newDst[3] = Math.max(a[3], b[3]);\n        return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.min(a[0], b[0]);\n        newDst[1] = Math.min(a[1], b[1]);\n        newDst[2] = Math.min(a[2], b[2]);\n        newDst[3] = Math.min(a[3], b[3]);\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        newDst[2] = v[2] * k;\n        newDst[3] = v[3] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        newDst[2] = v[2] / k;\n        newDst[3] = v[3] / k;\n        return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = 1 / v[0];\n        newDst[1] = 1 / v[1];\n        newDst[2] = 1 / v[2];\n        newDst[3] = 1 / v[3];\n        return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    const invert = inverse;\n    /**\n     * Computes the dot product of two vectors\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        const dw = a[3] - b[3];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    const dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        const dw = a[3] - b[3];\n        return dx * dx + dy * dy + dz * dz + dw * dw;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    const distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n            newDst[2] = v2 / len;\n            newDst[3] = v3 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n            newDst[3] = 0;\n        }\n        return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = -v[0];\n        newDst[1] = -v[1];\n        newDst[2] = -v[2];\n        newDst[3] = -v[3];\n        return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec4.clone})\n     * Also see {@link vec4.create} and {@link vec4.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0];\n        newDst[1] = v[1];\n        newDst[2] = v[2];\n        newDst[3] = v[3];\n        return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec4.copy})\n     * Also see {@link vec4.create} and {@link vec4.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    const clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] * b[0];\n        newDst[1] = a[1] * b[1];\n        newDst[2] = a[2] * b[2];\n        newDst[3] = a[3] * b[3];\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] / b[0];\n        newDst[1] = a[1] / b[1];\n        newDst[2] = a[2] / b[2];\n        newDst[3] = a[3] / b[3];\n        return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    const div = divide;\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        return newDst;\n    }\n    /**\n     * transform vec4 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec4 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        const w = v[3];\n        newDst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n        newDst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n        newDst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n        newDst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n        return newDst;\n    }\n    /**\n     * Treat a 4D vector as a direction and set it's length\n     *\n     * @param a The vec4 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        normalize(a, newDst);\n        return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec4 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        if (length(a) > maxLen) {\n            return setLength(a, maxLen, newDst);\n        }\n        return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        return lerp(a, b, 0.5, newDst);\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        ceil,\n        floor,\n        round,\n        clamp,\n        add,\n        addScaled,\n        subtract,\n        sub,\n        equalsApproximately,\n        equals,\n        lerp,\n        lerpV,\n        max,\n        min,\n        mulScalar,\n        scale,\n        divScalar,\n        inverse,\n        invert,\n        dot,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        distance,\n        dist,\n        distanceSq,\n        distSq,\n        normalize,\n        negate,\n        copy,\n        clone,\n        multiply,\n        mul,\n        divide,\n        div,\n        zero,\n        transformMat4,\n        setLength,\n        truncate,\n        midpoint,\n    };\n}\nconst cache = new Map();\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `newDst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nfunction getAPI(Ctor) {\n    let api = cache.get(Ctor);\n    if (!api) {\n        api = getAPIImpl(Ctor);\n        cache.set(Ctor, api);\n    }\n    return api;\n}\n\n/**\n * Some docs\n * @namespace wgpu-matrix\n */\n/**\n * Generate wgpu-matrix API for type\n */\nfunction wgpuMatrixAPI(Mat3Ctor, Mat4Ctor, QuatCtor, Vec2Ctor, Vec3Ctor, Vec4Ctor) {\n    return {\n        /** @namespace mat3 */\n        mat3: getAPI$3(Mat3Ctor),\n        /** @namespace mat4 */\n        mat4: getAPI$2(Mat4Ctor),\n        /** @namespace quat */\n        quat: getAPI$1(QuatCtor),\n        /** @namespace vec2 */\n        vec2: getAPI$5(Vec2Ctor),\n        /** @namespace vec3 */\n        vec3: getAPI$4(Vec3Ctor),\n        /** @namespace vec4 */\n        vec4: getAPI(Vec4Ctor),\n    };\n}\nconst { \n/**\n * 3x3 Matrix functions that default to returning `Float32Array`\n * @namespace\n */\nmat3, \n/**\n * 4x4 Matrix functions that default to returning `Float32Array`\n * @namespace\n */\nmat4, \n/**\n * Quaternion functions that default to returning `Float32Array`\n * @namespace\n */\nquat, \n/**\n * Vec2 functions that default to returning `Float32Array`\n * @namespace\n */\nvec2, \n/**\n * Vec3 functions that default to returning `Float32Array`\n * @namespace\n */\nvec3, \n/**\n * Vec3 functions that default to returning `Float32Array`\n * @namespace\n */\nvec4, } = wgpuMatrixAPI(Float32Array, Float32Array, Float32Array, Float32Array, Float32Array, Float32Array);\nconst { \n/**\n * 3x3 Matrix functions that default to returning `Float64Array`\n * @namespace\n */\nmat3: mat3d, \n/**\n * 4x4 Matrix functions that default to returning `Float64Array`\n * @namespace\n */\nmat4: mat4d, \n/**\n * Quaternion functions that default to returning `Float64Array`\n * @namespace\n */\nquat: quatd, \n/**\n * Vec2 functions that default to returning `Float64Array`\n * @namespace\n */\nvec2: vec2d, \n/**\n * Vec3 functions that default to returning `Float64Array`\n * @namespace\n */\nvec3: vec3d, \n/**\n * Vec3 functions that default to returning `Float64Array`\n * @namespace\n */\nvec4: vec4d, } = wgpuMatrixAPI(Float64Array, Float64Array, Float64Array, Float64Array, Float64Array, Float64Array);\nconst { \n/**\n * 3x3 Matrix functions that default to returning `number[]`\n * @namespace\n */\nmat3: mat3n, \n/**\n * 4x4 Matrix functions that default to returning `number[]`\n * @namespace\n */\nmat4: mat4n, \n/**\n * Quaternion functions that default to returning `number[]`\n * @namespace\n */\nquat: quatn, \n/**\n * Vec2 functions that default to returning `number[]`\n * @namespace\n */\nvec2: vec2n, \n/**\n * Vec3 functions that default to returning `number[]`\n * @namespace\n */\nvec3: vec3n, \n/**\n * Vec3 functions that default to returning `number[]`\n * @namespace\n */\nvec4: vec4n, } = wgpuMatrixAPI(ZeroArray, Array, Array, Array, Array, Array);\n\nexport { mat3, mat3d, mat3n, mat4, mat4d, mat4n, quat, quatd, quatn, utils, vec2, vec2d, vec2n, vec3, vec3d, vec3n, vec4, vec4d, vec4n };\n//# sourceMappingURL=wgpu-matrix.module.js.map\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.rv = () => (\"1.6.0\")","__webpack_require__.ruid = \"bundler=rspack@1.6.0\";\n","import { Renderer } from \"./Rendering/Renderer\";\nimport { Logic } from \"./Logic/Logic\";\nimport { Controller } from \"./Controller/Controller\";\nimport { Dialog } from \"./Logic/Dialog\";\n\nmain();\n\nasync function main() {\n    const theCanvas = document.querySelector(\"canvas\")!;\n    const dialogButton = document.querySelector(\"svg\")!;\n    const htmlDialog = document.querySelector(\"dialog\")!;\n\n    const renderer = await Renderer.create(theCanvas);\n    const logic = new Logic(renderer, theCanvas, dialogButton);\n    new Controller(logic, theCanvas);\n    new Dialog(logic, dialogButton, htmlDialog);\n}\n"],"names":["Controller","logic","htmlCanvas","e","document","onKeyTriggered","pressed","vec3","BoxCollider","ax","bx","ay","by","az","bz","hasCollision","otherCollider","noneX","noneY","noneZ","handleCollision","MinDistance","isA","isB","a","b","otherA","otherB","da","db","dx","dy","dz","Math","create","position","radius","Dialog","dialogButton","htmlDialog","time","Date","rect","rectBottom","rectRight","Number","localStorage","value","configsDiv","timerDiv","moveSpeedDiv","mouseSensitivtyDiv","Renderer","Mesh","mat4","Logic","renderer","Float32Array","Array","speed","xMovement","zMovement","brightness","lightDirectionY","sinY","lightDirectionX","lightDirectionZ","requestAnimationFrame","i","timeoutValue","moveSpeedValue","mouseSensitivityValue","window","handleCameraCollision","cameraCollider","digitCollider","pushAmount","cameraCollider1","sphereBoxCollider","lengthX","lengthY","lengthZ","distance","otherRadius","minDistance","distanceDif","i1","cubeCollider","pushAmount1","createDigitModels","DIGIT_LINE","SPACING","reset","model","translateX","topBar","boxCollider","middleBar","bottomBar","upperLeftBar","upperRightBar","lowerLeftBar","lowerRightBar","digits","barCount","digit","model1","spaceOffset","resultIndex","setWindowResized","rotateCamera","yaw","pitch","sensitivity","zoomCamera","zoom","ImageLoader","Image","loadPng","url","blob","createImageBitmap","loadSvg","width","height","svgBlob","pngBlob","loadSvgMipmaps","mipLevelCount","result","fetchImage","response","fetch","Error","svgToPng","Promise","resolve","reject","URL","vertices","indices","createSphere","size","longitude","latitude","circle45","horizintalAngles","hStep","currentStep","verticalAngles","vStep","currentStep1","horizontalLength","verticalLength","vertexPos","i2","middle","top","left","bottom","right","i3","x","z","top45","bottom45","i4","x1","z1","i5","y","x2","j","xx","zx","xy","zy","index","horizontalStep","verticalStep","step","i6","vStep1","i7","hStep1","j1","step1","i8","offset","index1","i9","i10","j2","topLeft","topRight","bottomLeft","bottomRight","totalLength","bottomStart","lastArray","i11","Uint16Array","SHADER_CODE","canvas","gpuAdapter","device","shaderModule","bitmaps","GPUTextureUsage","GPUBufferUsage","textureDescriptor","modelArray","temp","bindGroupLayout","GPUShaderStage","vertexLayout","renderStart","setObjectShader","renderLittleSphere","renderSphereCubes","renderDigits","modelsOfDigits","setBackgroundShader","renderBeckgound","renderEnd","view","projection","colorRotate","lightDirection","renewRenderTextures","createDepthStencilView","createMultisampleTexture","compilationInfo","_iteratorError","message","imageLoader","navigator","undefined","main","theCanvas"],"mappings":"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AA;kDAAAA;;;;gCAKT,WAAW;gCACLE,cAAc,IAAIvH,qDAAWA;gCACnB;;oCAAMuH,YAAY,cAAc,CAAC,gBAAgB,MAAM,MAAM;;;gCAAvE5B,UAAU;gCAEhB;;oCAAO,IA5DF3J,SA4DeuJ,QAAQC,YAAYC,QAAQC,cAAcC;;;;gBAClE;;;;WA7DS3J;IA+bZ;AA9bG,iBADSA,UACM,gBAAiC;AAChD,iBAFSA,UAEM,gBAAiC;AAChD,iBAHSA,UAGM,gBAAuB;AACtC,iBAJSA,UAIK,sBAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,iBAAiB,mBAAmB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAE0H;AACzI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACx3LA;AACA;AACA;AACA,kDAAkD,wCAAwC;AAC1F;AACA;AACA,E;;;;ACNA,wF;;;;ACAA;AACA;AACA;AACA,uDAAuD,iBAAiB;AACxE;AACA,gDAAgD,aAAa;AAC7D,E;;;;ACNA,wC;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAgD;AACV;AACe;AACb;AAExC0L;AAEA,SAAeA;;YACLC,WACAzM,cACAC,YAEAiB,UACAvD;;;;oBALA8O,YAAY3O,SAAS,aAAa,CAAC;oBACnCkC,eAAelC,SAAS,aAAa,CAAC;oBACtCmC,aAAanC,SAAS,aAAa,CAAC;oBAEzB;;wBAAMgD,gEAAe,CAAC2L;;;oBAAjCvL,WAAW;oBACXvD,QAAQ,IAAIsD,+CAAKA,CAACC,UAAUuL,WAAWzM;oBAC7C,IAAItC,8DAAUA,CAACC,OAAO8O;oBACtB,IAAI1M,iDAAMA,CAACpC,OAAOqC,cAAcC;;;;;;IACpC"}